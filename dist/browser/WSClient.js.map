{"version":3,"file":"WSClient.js","sources":["../../node_modules/@typhonjs-plugin/eventbus/src/utils.js","../../node_modules/@typhonjs-plugin/eventbus/src/Eventbus.js","../../node_modules/@typhonjs-plugin/eventbus/src/index.js","../../src/utils/Queue.js","../../src/utils/setClientOptions.js","../../src/AbstractWSClient.js","../../src/browser/WSClient.js"],"sourcesContent":["/**\n * Regular expression used to split event strings.\n *\n * @type {RegExp}\n */\nexport const eventSplitter = /\\s+/;\n\n/**\n * Iterates over the standard `event, callback` (as well as the fancy multiple space-separated events `\"change blur\",\n * callback` and jQuery-style event maps `{event: callback}`).\n *\n * @template T\n *\n * @param {Function}       iteratee - Event operation to invoke.\n *\n * @param {T}              events - Events object\n *\n * @param {string|object}  name - A single event name, compound event names, or a hash of event names.\n *\n * @param {Function}       callback - Event callback function\n *\n * @param {object}         opts - Optional parameters\n *\n * @returns {T} Events object or processed data.\n */\nexport function eventsAPI(iteratee, events, name, callback, opts)\n{\n   let i = 0, names;\n   if (name && typeof name === 'object')\n   {\n      // Handle event maps.\n      if (callback !== void 0 && 'context' in opts && opts.context === void 0) { opts.context = callback; }\n      for (names = objectKeys(name); i < names.length; i++)\n      {\n         events = eventsAPI(iteratee, events, names[i], name[names[i]], opts);\n      }\n   }\n   else if (name && eventSplitter.test(name))\n   {\n      // Handle space-separated event names by delegating them individually.\n      for (names = name.split(eventSplitter); i < names.length; i++)\n      {\n         events = iteratee(events, names[i], callback, opts);\n      }\n   }\n   else\n   {\n      // Finally, standard events.\n      events = iteratee(events, name, callback, opts);\n   }\n   return events;\n}\n\n/**\n * Returns a string to output for error messages including any eventbus name.\n *\n * @param {Eventbus|EventbusProxy|EventbusSecure} eventbus - The eventbus to format.\n *\n * @returns {string} A string representing the eventbus.\n */\nexport function getErrorName(eventbus)\n{\n   const name = eventbus.name;\n   return name !== '' ? `[${name}] ` : '';\n}\n\n/**\n * Provides  protected Object.keys functionality.\n *\n * @param {object}   object - Object to retrieve keys.\n *\n * @returns {string[]} Keys of object if any.\n */\nexport const objectKeys = (object) =>\n{\n   return object === null || typeof object !== 'object' ? [] : Object.keys(object);\n};\n\n/**\n * Reduces the event callbacks into a map of `{event: beforeWrapper}`. `after` unbinds the `beforeWrapper` after\n * it has been called the number of times specified by options.count.\n *\n * @param {Events}   map - Events object\n *\n * @param {string}   name - Event name\n *\n * @param {Function} callback - Event callback\n *\n * @param {object}   opts - Function to invoke after event has been triggered once; `off()`\n *\n * @returns {Events} The Events object.\n */\nexport function beforeMap(map, name, callback, opts)\n{\n   const after = opts.after;\n   const count = opts.count + 1;\n\n   if (callback)\n   {\n      const beforeWrapper = map[name] = s_BEFORE(count, function()\n      {\n         return callback.apply(this, arguments);\n      }, () => { after(name, beforeWrapper); });\n\n      beforeWrapper._callback = callback;\n   }\n   return map;\n}\n\n// Module Private ----------------------------------------------------------------------------------------------------\n\n/**\n * Creates a function that invokes `before`, with the `this` binding and arguments of the created function, while\n * it's called less than `count` times. Subsequent calls to the created function return the result of the last `before`\n * invocation.\n *\n * `after` is invoked after the count is reduced.\n *\n * @param {number}   count - The number of calls at which `before` is no longer invoked and then `after` is invoked.\n *\n * @param {Function} before - The function to restrict.\n *\n * @param {Function} after - The function to invoke after count number of calls.\n *\n * @returns {Function} Returns the new restricted function.\n */\nconst s_BEFORE = function(count, before, after)\n{\n   let result;\n\n   return function(...args)\n   {\n      if (--count > 0) { result = before.apply(this, args); }\n\n      if (count <= 1)\n      {\n         if (after) { after.apply(this, args); }\n         after = void 0;\n         before = void 0;\n      }\n\n      return result;\n   };\n};\n","import * as Utils from './utils.js';\n\n/**\n * `@typhonjs-plugin/eventbus` / Provides the ability to bind and trigger custom named events.\n *\n * This module is an evolution of Backbone Events. (http://backbonejs.org/#Events). Eventbus extends the\n * functionality provided in Backbone Events with additional triggering methods to receive asynchronous and\n * synchronous results.\n *\n * ---------------\n */\nexport default class Eventbus\n{\n   /**\n    * Stores the name of this eventbus.\n    *\n    * @type {string}\n    * @private\n    */\n   #name = '';\n\n   /**\n    * Stores the events map for associated events and callback / context data.\n    *\n    * @type {Events|{}}\n    * @private\n    */\n   #events;\n\n   /**\n    * Provides a constructor which optionally takes the eventbus name.\n    *\n    * @param {string}   name - Optional eventbus name.\n    */\n   constructor(name = '')\n   {\n      if (typeof name !== 'string') { throw new TypeError(`'name' is not a string`); }\n\n      this.#name = name;\n\n      /**\n       * Stores the Listening instances for this context.\n       *\n       * @type {object.<string, Listening>}\n       * @private\n       */\n      this._listeners = void 0;\n\n      /**\n       * A unique ID set when listened to.\n       *\n       * @type {string}\n       * @private\n       */\n      this._listenId = void 0;\n\n      /**\n       * Stores the Listening instances for other contexts.\n       *\n       * @type {object.<string, Listening>}\n       * @private\n       */\n      this._listeningTo = void 0;\n   }\n\n   /**\n    * Just like `on`, but causes the bound callback to fire several times up to the count specified before being\n    * removed. When multiple events are passed in using the space separated syntax, the event\n    * will fire count times for every event you passed in, not once for a combination of all events.\n    *\n    * @param {number}            count - Number of times the function will fire before being removed.\n    *\n    * @param {string|object}     name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @param {object}            [context] - Event context\n    *\n    * @param {OnOptions}         [options] - Event registration options.\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   before(count, name, callback, context = void 0, options = {})\n   {\n      if (!Number.isInteger(count)) { throw new TypeError(`'count' is not an integer`); }\n\n      const data = {};\n      if (this.isGuarded(name, data))\n      {\n         console.warn(`@typhonjs-plugin/eventbus ${Utils.getErrorName(this)}`\n          + `- before() failed as event name(s) are guarded: ${JSON.stringify(data.names)}`);\n         return this;\n      }\n\n      // Map the event into a `{event: beforeWrapper}` object.\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, { count, after: this.off.bind(this) });\n\n      if (typeof name === 'string' && (context === null || context === void 0)) { callback = void 0; }\n\n      return this.on(events, callback, context, options);\n   }\n\n   /**\n    * Returns an iterable for all stored events yielding an array with event name, callback function, and event context.\n    *\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\n    *\n    * @yields\n    */\n   *entries(regex = void 0)\n   {\n      if (regex !== void 0 && !(regex instanceof RegExp)) { throw new TypeError(`'regex' is not a RegExp`); }\n\n      if (!this.#events) { return; }\n\n      if (regex)\n      {\n         for (const name in this.#events)\n         {\n            if (regex.test(name))\n            {\n               for (const event of this.#events[name])\n               {\n                  yield [name, event.callback, event.context, JSON.parse(JSON.stringify(event.options))];\n               }\n            }\n         }\n      }\n      else\n      {\n         for (const name in this.#events)\n         {\n            for (const event of this.#events[name])\n            {\n               yield [name, event.callback, event.context, JSON.parse(JSON.stringify(event.options))];\n            }\n         }\n      }\n   }\n\n   /**\n    * Returns the current event count.\n    *\n    * @returns {number} Returns the current event count.\n    */\n   get eventCount()\n   {\n      if (!this.#events) { return 0; }\n\n      return Object.keys(this.#events).length;\n   }\n\n   /**\n    * Returns the current callback count.\n    *\n    * @returns {number} The current callback count.\n    */\n   get callbackCount()\n   {\n      if (!this.#events) { return 0; }\n\n      let count = 0;\n\n      for (const name in this.#events) { count += this.#events[name].length; }\n\n      return count;\n   }\n\n   /**\n    * Returns whether an event name is guarded.\n    *\n    * @param {string|object}  name - Event name(s) or event map to verify.\n    *\n    * @param {object}         [data] - Stores the output of which names are guarded.\n    *\n    * @returns {boolean} Whether the given event name is guarded.\n    */\n   isGuarded(name, data = {})\n   {\n      data.names = [];\n      data.guarded = false;\n\n      const result = Utils.eventsAPI(s_IS_GUARDED, data, name, void 0, { events: this.#events });\n\n      return result.guarded;\n   }\n\n   /**\n    * Returns an iterable for the event names / keys of registered event listeners.\n    *\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\n    *\n    * @yields\n    */\n   *keys(regex = void 0)\n   {\n      if (regex !== void 0 && !(regex instanceof RegExp)) { throw new TypeError(`'regex' is not a RegExp`); }\n\n      if (!this.#events) { return; }\n\n      if (regex)\n      {\n         for (const name in this.#events)\n         {\n            if (regex.test(name))\n            {\n               yield name;\n            }\n         }\n      }\n      else\n      {\n         for (const name in this.#events)\n         {\n            yield name;\n         }\n      }\n   }\n\n   /**\n    * Returns the current eventbus name.\n    *\n    * @returns {string} The current eventbus name.\n    */\n   get name()\n   {\n      return this.#name;\n   }\n\n   /**\n    * Tell an object to listen to a particular event on an other object. The advantage of using this form, instead of\n    * other.on(event, callback, object), is that listenTo allows the object to keep track of the events, and they can\n    * be removed all at once later on. The callback will always be called with object as context.\n    *\n    * @example\n    * view.listenTo(model, 'change', view.render);\n    *\n    * @param {object}            obj - Event context\n    *\n    * @param {string|object}     name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   listenTo(obj, name, callback)\n   {\n      if (!obj) { return this; }\n\n      const data = {};\n      if (s_TRY_CATCH_IS_GUARDED(obj, name, data))\n      {\n         console.warn(`@typhonjs-plugin/eventbus ${Utils.getErrorName(this)}`\n          + `- listenTo() failed as event name(s) are guarded for target object: ${JSON.stringify(data.names)}`);\n         return this;\n      }\n\n      const id = obj._listenId || (obj._listenId = s_UNIQUE_ID('l'));\n      const listeningTo = this._listeningTo || (this._listeningTo = {});\n      let listening = _listening = listeningTo[id];\n\n      // This object is not listening to any other events on `obj` yet.\n      // Setup the necessary references to track the listening callbacks.\n      if (!listening)\n      {\n         this._listenId || (this._listenId = s_UNIQUE_ID('l'));\n         listening = _listening = listeningTo[id] = new Listening(this, obj);\n      }\n\n      // Bind callbacks on obj.\n      const error = s_TRY_CATCH_ON(obj, name, callback, this);\n      _listening = void 0;\n\n      if (error) { throw error; }\n\n      // If the target obj is not an Eventbus, track events manually.\n      if (listening.interop) { listening.on(name, callback); }\n\n      return this;\n   }\n\n   /**\n    * Just like `listenTo`, but causes the bound callback to fire count times before being removed.\n    *\n    * @param {number}            count - Number of times the function will fire before being removed.\n    *\n    * @param {object}            obj - Target event context.\n    *\n    * @param {string|object}     name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   listenToBefore(count, obj, name, callback)\n   {\n      if (!Number.isInteger(count)) { throw new TypeError(`'count' is not an integer`); }\n\n      // Map the event into a `{event: beforeWrapper}` object.\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, {\n         count,\n         after: this.stopListening.bind(this, obj)\n      });\n\n      return this.listenTo(obj, events);\n   }\n\n   /**\n    * Just like `listenTo`, but causes the bound callback to fire only once before being removed.\n    *\n    * @param {object}            obj - Target event context\n    *\n    * @param {string|object}     name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   listenToOnce(obj, name, callback)\n   {\n      // Map the event into a `{event: beforeWrapper}` object.\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, {\n         count: 1,\n         after: this.stopListening.bind(this, obj)\n      });\n\n      return this.listenTo(obj, events);\n   }\n\n   /**\n    * Remove a previously-bound callback function from an object. If no context is specified, all of the versions of\n    * the callback with different contexts will be removed. If no callback is specified, all callbacks for the event\n    * will be removed. If no event is specified, callbacks for all events will be removed.\n    *\n    * Note that calling model.off(), for example, will indeed remove all events on the model — including events that\n    * Backbone uses for internal bookkeeping.\n    *\n    * @example\n    * // Removes just the `onChange` callback.\n    * object.off(\"change\", onChange);\n    *\n    * // Removes all \"change\" callbacks.\n    * object.off(\"change\");\n    *\n    * // Removes the `onChange` callback for all events.\n    * object.off(null, onChange);\n    *\n    * // Removes all callbacks for `context` for all events.\n    * object.off(null, null, context);\n    *\n    * // Removes all callbacks on `object`.\n    * object.off();\n    *\n    * @param {string|object}  [name] - Event name(s) or event map.\n    *\n    * @param {Function}       [callback] - Event callback function\n    *\n    * @param {object}         [context] - Event context\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   off(name, callback = void 0, context = void 0)\n   {\n      if (!this.#events) { return this; }\n\n      this.#events = Utils.eventsAPI(s_OFF_API, this.#events, name, callback, { context, listeners: this._listeners });\n\n      return this;\n   }\n\n   /**\n    * Bind a callback function to an object. The callback will be invoked whenever the event is fired. If you have a\n    * large number of different events on a page, the convention is to use colons to namespace them: \"poll:start\", or\n    * \"change:selection\".\n    *\n    * To supply a context value for this when the callback is invoked, pass the optional last argument:\n    * model.on('change', this.render, this) or model.on({change: this.render}, this).\n    *\n    * @example\n    * The event string may also be a space-delimited list of several events...\n    * book.on(\"change:title change:author\", ...);\n    *\n    * @example\n    * Callbacks bound to the special \"all\" event will be triggered when any event occurs, and are passed the name of\n    * the event as the first argument. For example, to proxy all events from one object to another:\n    * proxy.on(\"all\", function(eventName) {\n    *    object.trigger(eventName);\n    * });\n    *\n    * @example\n    * All Backbone event methods also support an event map syntax, as an alternative to positional arguments:\n    * book.on({\n    *    \"change:author\": authorPane.update,\n    *    \"change:title change:subtitle\": titleView.update,\n    *    \"destroy\": bookView.remove\n    * });\n    *\n    * @param {string|object}     name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @param {object}            [context] - Event context\n    *\n    * @param {OnOptions}         [options] - Event registration options.\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   on(name, callback, context = void 0, options = {})\n   {\n      if (options == null || options.constructor !== Object)   // eslint-disable-line eqeqeq\n      {\n         throw new TypeError(`'options' must be an object literal.`);\n      }\n\n      const data = {};\n      if (this.isGuarded(name, data))\n      {\n         console.warn(`@typhonjs-plugin/eventbus ${Utils.getErrorName(this)}`\n          + `- on() failed as event name(s) are guarded: ${JSON.stringify(data.names)}`);\n         return this;\n      }\n\n      this.#events = Utils.eventsAPI(s_ON_API, this.#events || {}, name, callback, {\n         context,\n         ctx: this,\n         options,\n         listening: _listening\n      });\n\n      if (_listening)\n      {\n         const listeners = this._listeners || (this._listeners = {});\n         listeners[_listening.id] = _listening;\n\n         // Allow the listening to use a counter, instead of tracking callbacks for library interop.\n         _listening.interop = false;\n      }\n\n      return this;\n   }\n\n   /**\n    * Just like `on`, but causes the bound callback to fire only once before being removed. Handy for saying \"the next\n    * time that X happens, do this\". When multiple events are passed in using the space separated syntax, the event\n    * will fire once for every event you passed in, not once for a combination of all events\n    *\n    * @param {string|object}     name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @param {object}            [context] - Event context.\n    *\n    * @param {OnOptions}         [options] - Event registration options.\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   once(name, callback, context = void 0, options = {})\n   {\n      const data = {};\n      if (this.isGuarded(name, data))\n      {\n         console.warn(`@typhonjs-plugin/eventbus ${Utils.getErrorName(this)}`\n          + `- once() failed as event name(s) are guarded: ${JSON.stringify(data.names)}`);\n         return this;\n      }\n\n      // Map the event into a `{event: beforeWrapper}` object.\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, { count: 1, after: this.off.bind(this) });\n\n      if (typeof name === 'string' && (context === null || context === void 0)) { callback = void 0; }\n\n      return this.on(events, callback, context, options);\n   }\n\n   /**\n    * Tell an object to stop listening to events. Either call stopListening with no arguments to have the object remove\n    * all of its registered callbacks ... or be more precise by telling it to remove just the events it's listening to\n    * on a specific object, or a specific event, or just a specific callback.\n    *\n    * @example\n    * view.stopListening();\n    *\n    * view.stopListening(model);\n    *\n    * @param {object}   obj - Event context\n    *\n    * @param {string}   [name] - Event name(s)\n    *\n    * @param {Function} [callback] - Event callback function\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   stopListening(obj, name = void 0, callback = void 0)\n   {\n      const listeningTo = this._listeningTo;\n      if (!listeningTo) { return this; }\n\n      const ids = obj ? [obj._listenId] : Utils.objectKeys(listeningTo);\n\n      for (let i = 0; i < ids.length; i++)\n      {\n         const listening = listeningTo[ids[i]];\n\n         // If listening doesn't exist, this object is not currently listening to obj. Break out early.\n         if (!listening) { break; }\n\n         listening.obj.off(name, callback, this);\n\n         if (listening.interop) { listening.off(name, callback); }\n      }\n\n      return this;\n   }\n\n   /**\n    * Trigger callbacks for the given event, or space-delimited list of events. Subsequent arguments to trigger will be\n    * passed along to the event callbacks.\n    *\n    * @param {string}   name - Event name(s)\n    *\n    * @param {...*}     args - Additional arguments passed to the event function(s).\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   trigger(name, ...args)\n   {\n      if (!this.#events) { return this; }\n\n      s_RESULTS_TARGET_API(s_TRIGGER_API, s_TRIGGER_EVENTS, this.#events, name, void 0, args);\n\n      return this;\n   }\n\n   /**\n    * Provides `trigger` functionality, but collects any returned Promises from invoked targets and returns a\n    * single Promise generated by `Promise.resolve` for a single value or `Promise.all` for multiple results. This is\n    * a very useful mechanism to invoke asynchronous operations over an eventbus.\n    *\n    * @param {string}   name - Event name(s)\n    *\n    * @param {...*}     args - Additional arguments passed to the event function(s).\n    *\n    * @returns {Promise<void|*|*[]>} A Promise with any results.\n    */\n   async triggerAsync(name, ...args)\n   {\n      if (!this.#events) { return void 0; }\n\n      const result = s_RESULTS_TARGET_API(s_TRIGGER_API, s_TRIGGER_ASYNC_EVENTS, this.#events, name, void 0, args);\n\n      // No event callbacks were triggered.\n      if (result === void 0) { return void 0; }\n\n      // A single Promise has been returned; just return it.\n      if (!Array.isArray(result)) { return result; }\n\n      // Multiple events & callbacks have been triggered so reduce the returned array of Promises and filter all\n      // values from each Promise result removing any undefined values.\n      return Promise.all(result).then((results) =>\n      {\n         let allResults = [];\n\n         for (const pResult of results)\n         {\n            if (Array.isArray(pResult))\n            {\n               allResults = allResults.concat(pResult);\n            }\n            else if (pResult !== void 0)\n            {\n               allResults.push(pResult);\n            }\n         }\n\n         return allResults.length > 1 ? allResults : allResults.length === 1 ? allResults[0] : void 0;\n      });\n   }\n\n   /**\n    * Defers invoking `trigger`. This is useful for triggering events in the next clock tick.\n    *\n    * @param {string}   name - Event name(s)\n    *\n    * @param {...*}     args - Additional arguments passed to the event function(s).\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   triggerDefer(name, ...args)\n   {\n      setTimeout(() => { this.trigger(name, ...args); }, 0);\n\n      return this;\n   }\n\n   /**\n    * Provides `trigger` functionality, but collects any returned result or results from invoked targets as a single\n    * value or in an array and passes it back to the callee in a synchronous manner.\n    *\n    * @param {string}   name - Event name(s).\n    *\n    * @param {...*}     args - Additional arguments passed to the event function(s).\n    *\n    * @returns {void|*|*[]} The results of the event invocation.\n    */\n   triggerSync(name, ...args)\n   {\n      if (!this.#events) { return void 0; }\n\n      return s_RESULTS_TARGET_API(s_TRIGGER_API, s_TRIGGER_SYNC_EVENTS, this.#events, name, void 0, args);\n   }\n}\n\n// Private / internal methods ---------------------------------------------------------------------------------------\n\n/**\n * Global listening object\n *\n * @type {Listening}\n */\nlet _listening;\n\n/**\n * A listening class that tracks and cleans up memory bindings when all callbacks have been offed.\n */\nclass Listening\n{\n   /**\n    * @type {Events|{}}\n    */\n   #events;\n\n   /**\n    * @type {string}\n    */\n   #id;\n\n   /**\n    * @type {object}\n    */\n   #listener;\n\n   /**\n    * @type {object}\n    */\n   #obj;\n\n   /**\n    * @type {boolean}\n    */\n   #interop;\n\n   /**\n    * Current listening count.\n    *\n    * @type {number}\n    */\n   #count = 0;\n\n   constructor(listener, obj)\n   {\n      this.#id = listener._listenId;\n      this.#listener = listener;\n      this.#obj = obj;\n      this.#interop = true;\n   }\n\n   // Cleans up memory bindings between the listener and the listenee.\n   cleanup()\n   {\n      delete this.#listener._listeningTo[this.#obj._listenId];\n      if (!this.#interop) { delete this.#obj._listeners[this.#id]; }\n   }\n\n   get id() { return this.#id; }\n\n   get interop() { return this.#interop; }\n\n   get obj() { return this.#obj; }\n\n   incrementCount() { this.#count++; }\n\n   /**\n    * @see {@link Eventbus#on}\n    *\n    * @param {string|object}     name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @param {object}            [context] - Event context\n    *\n    * @returns {Listening} This Listening instance.\n    */\n   on(name, callback, context = void 0)\n   {\n      this.#events = Utils.eventsAPI(s_ON_API, this.#events || {}, name, callback,\n      {\n         context,\n         ctx: this,\n         options: {},\n         listening: this\n      });\n\n      return this;\n   }\n\n   /**\n    * Offs a callback (or several). Uses an optimized counter if the listenee uses Eventbus. Otherwise, falls back to\n    * manual tracking to support events library interop.\n    *\n    * @param {string|object}     [name] - Event name(s) or event map.\n    *\n    * @param {Function|object}   [callback] - Event callback function or context for event map.\n    */\n   off(name, callback)\n   {\n      let cleanup;\n\n      if (this.#interop)\n      {\n         this.#events = Utils.eventsAPI(s_OFF_API, this.#events, name, callback, {\n            context: void 0,\n            listeners: void 0\n         });\n         cleanup = !this.#events;\n      }\n      else\n      {\n         this.#count--;\n         cleanup = this.#count === 0;\n      }\n\n      if (cleanup) { this.cleanup(); }\n   }\n\n   /**\n    * Sets interop.\n    *\n    * @param {boolean} value Value to set.\n    */\n   set interop(value)\n   {\n      /* c8 ignore next 1 */\n      if (typeof value !== 'boolean') { throw new TypeError(`'value' is not a boolean`); }\n      this.#interop = value\n   }\n}\n\n/**\n * The reducing API that tests if an event name is guarded. Any event data of a give event name can have the guarded\n * state set. If so the event name will be added to the output names array and `output.guarded` set to true.\n *\n * @param {object}   output - The output object.\n *\n * @param {string}   name - Event name\n *\n * @param {Function} callback - Event callback\n *\n * @param {object}   opts - Optional parameters\n *\n * @returns {object} The output object.\n */\nconst s_IS_GUARDED = (output, name, callback, opts) =>\n{\n   const events = opts.events;\n\n   if (events)\n   {\n      const handlers = events[name];\n\n      if (Array.isArray(handlers))\n      {\n         for (const handler of handlers)\n         {\n            if (handler.options.guard)\n            {\n                output.names.push(name);\n                output.guarded = true;\n                return output;\n            }\n         }\n      }\n   }\n\n   return output;\n}\n\n/**\n * The reducing API that removes a callback from the `events` object.\n *\n * @param {Events}   events - Events object\n *\n * @param {string}   name - Event name\n *\n * @param {Function} callback - Event callback\n *\n * @param {object}   opts - Optional parameters\n *\n * @returns {void|Events} Events object\n */\nconst s_OFF_API = (events, name, callback, opts) =>\n{\n   /* c8 ignore next 1 */\n   if (!events) { return; }\n\n   const context = opts.context, listeners = opts.listeners;\n   let i = 0, names;\n\n   // Delete all event listeners and \"drop\" events.\n   if (!name && !context && !callback)\n   {\n      for (names = Utils.objectKeys(listeners); i < names.length; i++)\n      {\n         listeners[names[i]].cleanup();\n      }\n      return;\n   }\n\n   names = name ? [name] : Utils.objectKeys(events);\n\n   for (; i < names.length; i++)\n   {\n      name = names[i];\n      const handlers = events[name];\n\n      // Bail out if there are no events stored.\n      if (!handlers) { break; }\n\n      // Find any remaining events.\n      const remaining = [];\n      for (let j = 0; j < handlers.length; j++)\n      {\n         const handler = handlers[j];\n         if (callback && callback !== handler.callback && callback !== handler.callback._callback ||\n          context && context !== handler.context)\n         {\n            remaining.push(handler);\n         }\n         else\n         {\n            const listening = handler.listening;\n            if (listening) { listening.off(name, callback); }\n         }\n      }\n\n      // Replace events if there are any remaining.  Otherwise, clean up.\n      if (remaining.length)\n      {\n         events[name] = remaining;\n      }\n      else\n      {\n         delete events[name];\n      }\n   }\n\n   return events;\n};\n\n/**\n * The reducing API that adds a callback to the `events` object.\n *\n * @param {Events}   events - Events object\n *\n * @param {string}   name - Event name\n *\n * @param {Function} callback - Event callback\n *\n * @param {object}   opts - Optional parameters\n *\n * @returns {Events} Events object.\n */\nconst s_ON_API = (events, name, callback, opts) =>\n{\n   if (callback)\n   {\n      const handlers = events[name] || (events[name] = []);\n      const context = opts.context, ctx = opts.ctx, listening = opts.listening;\n\n      // Make a copy of options.\n      const options = JSON.parse(JSON.stringify(opts.options));\n\n      // Ensure that guard is set.\n      options.guard = options.guard !== void 0 && typeof options.guard === 'boolean' ? options.guard : false;\n\n      if (listening) { listening.incrementCount(); }\n\n      handlers.push({ callback, context, ctx: context || ctx, options, listening });\n   }\n   return events;\n};\n\n/**\n * Iterates over the standard `event, callback` (as well as the fancy multiple space-separated events `\"change blur\",\n * callback` and jQuery-style event maps `{event: callback}`).\n *\n * @param {Function} iteratee - Trigger API\n *\n * @param {Function} iterateeTarget - Internal function which is dispatched to.\n *\n * @param {Events|{}}   events - Array of stored event callback data.\n *\n * @param {string}   name - Event name\n *\n * @param {Function} callback - callback\n *\n * @param {object}   opts - Optional parameters\n *\n * @returns {*} The results of the callback if any.\n */\nconst s_RESULTS_TARGET_API = (iteratee, iterateeTarget, events, name, callback, opts) =>\n{\n   let results = void 0;\n   let i = 0, names;\n\n   // Handle the case of multiple events being triggered. The potential results of each event & callbacks must be\n   // processed into a single array of results.\n   if (name && Utils.eventSplitter.test(name))\n   {\n      // Handle space-separated event names by delegating them individually.\n      for (names = name.split(Utils.eventSplitter); i < names.length; i++)\n      {\n         const result = iteratee(iterateeTarget, events, names[i], callback, opts);\n\n         // Determine type of `results`; 0: undefined, 1: single value, 2: an array of values.\n         const resultsType = Array.isArray(results) ? 2 : results !== void 0 ? 1 : 0;\n\n         // Handle an array result depending on existing results value.\n         if (Array.isArray(result))\n         {\n            switch (resultsType)\n            {\n               case 0:\n                  // Simply set results.\n                  results = result;\n                  break;\n               case 1:\n                  // Create a new array from existing results then concat the new result array.\n                  results = [results].concat(result);\n                  break;\n               case 2:\n                  // `results` is already an array so concat the new result array.\n                  results = results.concat(result);\n                  break;\n            }\n         }\n         else if (result !== void 0)\n         {\n            switch (resultsType)\n            {\n               case 0:\n                  // Simply set results.\n                  results = result;\n                  break;\n               case 1: {\n                  // Create a new array from existing results then push the new result value.\n                  const newArray = [results];\n                  newArray.push(result);\n                  results = newArray;\n                  break;\n               }\n               case 2:\n                  // `results` is already an array so push the new result array.\n                  results.push(result);\n                  break;\n            }\n         }\n      }\n   }\n   else\n   {\n      // Just single event.\n      results = iteratee(iterateeTarget, events, name, callback, opts);\n   }\n\n   return results;\n};\n\n/**\n * Handles triggering the appropriate event callbacks.\n *\n * @param {Function} iterateeTarget - Internal function which is dispatched to.\n *\n * @param {Events}   objEvents - Array of stored event callback data.\n *\n * @param {string}   name - Event name\n *\n * @param {Function} callback - callback\n *\n * @param {*[]}      args - Arguments supplied to a trigger method.\n *\n * @returns {*} The results from the triggered event.\n */\nconst s_TRIGGER_API = (iterateeTarget, objEvents, name, callback, args) =>\n{\n   let result;\n\n   if (objEvents)\n   {\n      const events = objEvents[name];\n      let allEvents = objEvents.all;\n      if (events && allEvents) { allEvents = allEvents.slice(); }\n      if (events) { result = iterateeTarget(events, args); }\n      if (allEvents) { result = iterateeTarget(allEvents, [name].concat(args)); }\n   }\n\n   return result;\n};\n\n/**\n * A difficult-to-believe, but optimized internal dispatch function for triggering events. Tries to keep the usual\n * cases speedy (most internal Backbone events have 3 arguments).\n *\n * @param {EventData[]} events - Array of stored event callback data.\n *\n * @param {*[]}         args - Event argument array\n */\nconst s_TRIGGER_EVENTS = (events, args) =>\n{\n   let ev, i = -1;\n   const a1 = args[0], a2 = args[1], a3 = args[2], l = events.length;\n\n   switch (args.length)\n   {\n      case 0:\n         while (++i < l) { (ev = events[i]).callback.call(ev.ctx); }\n         return;\n      case 1:\n         while (++i < l) { (ev = events[i]).callback.call(ev.ctx, a1); }\n         return;\n      case 2:\n         while (++i < l) { (ev = events[i]).callback.call(ev.ctx, a1, a2); }\n         return;\n      case 3:\n         while (++i < l) { (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); }\n         return;\n      default:\n         while (++i < l) { (ev = events[i]).callback.apply(ev.ctx, args); }\n         return;\n   }\n};\n\n/**\n * A difficult-to-believe, but optimized internal dispatch function for triggering events. Tries to keep the usual\n * cases speedy (most internal Backbone events have 3 arguments). This dispatch method uses ES6 Promises and adds\n * any returned results to an array which is added to a Promise.all construction which passes back a Promise which\n * waits until all Promises complete. Any target invoked may return a Promise or any result. This is very useful to\n * use for any asynchronous operations.\n *\n * @param {EventData[]} events - Array of stored event callback data.\n *\n * @param {*[]}         args - Arguments supplied to `triggerAsync`.\n *\n * @returns {Promise<void|*|*[]>} A Promise of the results from the triggered event.\n */\nconst s_TRIGGER_ASYNC_EVENTS = async (events, args) =>\n{\n   let ev, i = -1;\n   const a1 = args[0], a2 = args[1], a3 = args[2], l = events.length;\n\n   const results = [];\n\n   switch (args.length)\n   {\n      case 0:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx);\n\n            // If we received a valid result add it to the promises array.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n\n      case 1:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx, a1);\n\n            // If we received a valid result add it to the promises array.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n\n      case 2:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx, a1, a2);\n\n            // If we received a valid result add it to the promises array.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n\n      case 3:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);\n\n            // If we received a valid result add it to the promises array.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n\n      default:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.apply(ev.ctx, args);\n\n            // If we received a valid result add it to the promises array.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n   }\n\n   // If there are multiple results then use Promise.all otherwise Promise.resolve. Filter out any undefined results.\n   return results.length > 1 ? Promise.all(results).then((values) =>\n   {\n      const filtered = values.filter((entry) => entry !== void 0);\n      switch (filtered.length)\n      {\n         case 0: return void 0;\n         case 1: return filtered[0];\n         default: return filtered;\n      }\n   }) : results.length === 1 ? results[0] : void 0;\n};\n\n/**\n * A difficult-to-believe, but optimized internal dispatch function for triggering events. Tries to keep the usual\n * cases speedy (most internal Backbone events have 3 arguments). This dispatch method synchronously passes back a\n * single value or an array with all results returned by any invoked targets.\n *\n * @param {EventData[]} events - Array of stored event callback data.\n *\n * @param {*[]}         args - Arguments supplied to `triggerSync`.\n *\n * @returns {void|*|*[]} The results from the triggered event.\n */\nconst s_TRIGGER_SYNC_EVENTS = (events, args) =>\n{\n   let ev, i = -1;\n   const a1 = args[0], a2 = args[1], a3 = args[2], l = events.length;\n\n   const results = [];\n\n   switch (args.length)\n   {\n      case 0:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx);\n\n            // If we received a valid result return immediately.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n      case 1:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx, a1);\n\n            // If we received a valid result return immediately.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n      case 2:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx, a1, a2);\n\n            // If we received a valid result return immediately.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n      case 3:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);\n\n            // If we received a valid result return immediately.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n      default:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.apply(ev.ctx, args);\n\n            // If we received a valid result return immediately.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n   }\n\n   // Return the results array if there are more than one or just a single result.\n   return results.length > 1 ? results : results.length === 1 ? results[0] : void 0;\n};\n\n/**\n * A try-catch guarded function. Used when attempting to invoke `isGuarded` from an other eventbus / context via\n * `listenTo`.\n *\n * @param {object}         obj - Event target / context\n *\n * @param {string|object}  name - Event name(s) or event map.\n *\n * @param {object}         data - Output data.\n *\n * @returns {boolean} Any error if thrown.\n */\nconst s_TRY_CATCH_IS_GUARDED = (obj, name, data = {}) =>\n{\n   let guarded = false;\n\n   try\n   {\n      const result = obj.isGuarded(name, data);\n      if (typeof result === 'boolean') { guarded = result; }\n   }\n   catch (err)\n   {\n      guarded = false;\n      data.names = [];\n      data.guarded = false;\n   }\n\n   return guarded;\n};\n\n/**\n * A try-catch guarded #on function, to prevent poisoning the global `_listening` variable. Used when attempting to\n * invoke `on` from an other eventbus / context via `listenTo`.\n *\n * @param {object}            obj - Event target / context\n *\n * @param {string|object}     name - Event name(s) or event map.\n *\n * @param {Function|object}   callback - Event callback function or context for event map.\n *\n * @param {object}            [context] - Event context\n *\n * @returns {Error} Any error if thrown.\n */\nconst s_TRY_CATCH_ON = (obj, name, callback, context) =>\n{\n   try\n   {\n      obj.on(name, callback, context);\n   }\n   catch (err)\n   {\n      return err;\n   }\n};\n\n/**\n * Generate a unique integer ID (unique within the entire client session).\n *\n * @type {number} - unique ID counter.\n */\nlet idCounter = 0;\n\n/**\n * Creates a new unique ID with a given prefix\n *\n * @param {string}   prefix - An optional prefix to add to unique ID.\n *\n * @returns {string} A new unique ID with a given prefix.\n */\nconst s_UNIQUE_ID = (prefix = '') =>\n{\n   const id = `${++idCounter}`;\n   return prefix ? `${prefix}${id}` /* c8 ignore next */ : id;\n};\n","import Eventbus                        from './Eventbus.js';\n\nexport { default as EventbusProxy }    from './EventbusProxy.js';\nexport { default as EventbusSecure }   from './EventbusSecure.js';\n\nexport default Eventbus;\n\n/**\n * Provides a main eventbus instance.\n *\n * @type {Eventbus}\n */\nexport const eventbus = new Eventbus('mainEventbus');\n\n/**\n * Provides an eventbus instance potentially for use with a plugin system.\n *\n * @type {Eventbus}\n */\nexport const pluginEventbus = new Eventbus('pluginEventbus');\n\n/**\n * Provides an eventbus instance potentially for use for testing.\n *\n * @type {Eventbus}\n */\nexport const testEventbus = new Eventbus('testEventbus');\n","/**\n * Provides a single consumer queue.\n */\nexport default class Queue\n{\n   /**\n    * As the name implies, `consumer` is the sole consumer of the queue. It gets called with each element of the\n    * queue and its return value serves as a ack, determining whether the element is removed or not from the queue,\n    * allowing then subsequent elements to be processed.\n    *\n    * @param {Function} consumer - The sole consumer of the queue.\n    */\n   constructor(consumer)\n   {\n      /**\n       * The consumer of the queue.\n       *\n       * @type {Function}\n       */\n      this.consumer = consumer;\n\n      /**\n       * Storage for the queue.\n       *\n       * @type {Array}\n       */\n      this.queue = [];\n   }\n\n   /**\n    * Pushes an element on the queue.\n    *\n    * @param {*}  element - An element.\n    *\n    * @returns {Queue} This queue instance.\n    */\n   push(element)\n   {\n      this.queue.push(element);\n\n      return this.process();\n   }\n\n   /**\n    * Pushes an element on the queue.\n    *\n    * @param {Iterable<*>}  elements - An array of elements.\n    *\n    * @returns {Queue} This queue instance.\n    */\n   pushAll(elements)\n   {\n      this.queue.push(...elements);\n\n      return this.process();\n   }\n\n   /**\n    * Processes the queue.\n    *\n    * @returns {Queue} This queue instance.\n    */\n   process()\n   {\n      setTimeout(() =>\n      {\n         if (this.queue.length !== 0)\n         {\n            const ack = this.consumer(this.queue[0]);\n            if (ack)\n            {\n               this.queue.shift();\n               this.process();\n            }\n         }\n      }, 0);\n\n      return this;\n   }\n\n   /**\n    * Empties the queue.\n    *\n    * @returns {Queue} This queue instance.\n    */\n   empty()\n   {\n      this.queue = [];\n\n      return this;\n   }\n}\n","const s_DEFAULT_AUTO_CONNECT = false;\nconst s_DEFAULT_AUTO_RECONNECT = false;\nconst s_DEFAULT_BINARY_TYPE = 'blob';\nconst s_DEFAULT_CONNECT_TIMEOUT = 5000;\nconst s_DEFAULT_HOST = 'localhost';\nconst s_DEFAULT_MESSAGE_TIMEOUT = 10000;\nconst s_DEFAULT_PATH = '/';\nconst s_DEFAULT_RECONNECT_INTERVAL = 2000;\nconst s_DEFAULT_SERIALIZER = JSON;\nconst s_DEFAULT_SSL = false;\nconst s_DEFAULT_TRIGGER = true;\n\n/**\n * Parses and new client options setting default values as necessary.\n *\n * @param {NewClientOptions}  opts - Defines the options for a WebSocket client.\n *\n * @returns {ClientOptions} The parsed client options object.\n */\nexport default function setClientOptions(opts)\n{\n   if (opts === null || opts === void 0)\n   {\n      throw new TypeError(`'clientOptions' is null or undefined.`);\n   }\n\n   if (typeof opts !== 'object')\n   {\n      throw new TypeError(`'clientOptions' is not an object.`);\n   }\n\n   if (opts.url !== void 0 && typeof opts.url !== 'string' && !(opts.url instanceof URL))\n   {\n      throw new TypeError(`'clientOptions.url' is not a string or URL.`);\n   }\n\n   let url = typeof opts.url === 'string' ? new URL(opts.url.toLowerCase()) : opts.url;\n\n   if (url !== void 0 && !url.protocol.match(/^wss?/))\n   {\n      throw new TypeError(`'clientOptions.url' is not a WebSocket URL.`);\n   }\n\n   if ((url === void 0 && !Number.isInteger(opts.port)) || (opts.port < 0 || opts.port > 65535))\n   {\n      throw new TypeError(`'clientOptions.port' is not an integer between [0-65535].`);\n   }\n\n   if (opts.host !== void 0 && typeof opts.host !== 'string')\n   {\n      throw new TypeError(`'clientOptions.host' is not a string.`);\n   }\n\n   opts.host = opts.host || s_DEFAULT_HOST;\n\n   if (opts.ssl !== void 0 && typeof opts.ssl !== 'boolean')\n   {\n      throw new TypeError(`'clientOptions.ssl' is not a boolean.`);\n   }\n\n   opts.ssl = typeof opts.ssl === 'boolean' ? opts.ssl : s_DEFAULT_SSL;\n\n   if (opts.path !== void 0 && typeof opts.path !== 'string')\n   {\n      throw new TypeError(`'clientOptions.path' is not a string.`);\n   }\n\n   opts.path = typeof opts.path === 'string' ? opts.path : s_DEFAULT_PATH;\n\n   // Add a leading slash if necessary to normalize path.\n   if (!opts.path.startsWith('/')) { opts.path = `/${opts.path}`; }\n\n   if (opts.binaryType !== void 0 && typeof opts.binaryType !== 'string')\n   {\n      throw new TypeError(`'clientOptions.binaryType' must be 'blob' or 'arraybuffer'.`);\n   }\n\n   if (opts.binaryType !== void 0 && opts.binaryType !== 'blob' && opts.binaryType !== 'arraybuffer')\n   {\n      throw new TypeError(`'clientOptions.binaryType' must be 'blob' or 'arraybuffer'.`);\n   }\n\n   opts.binaryType = typeof opts.binaryType === 'string' ? opts.binaryType : s_DEFAULT_BINARY_TYPE;\n\n\n   opts.serializer = opts.serializer || s_DEFAULT_SERIALIZER;\n\n   if (typeof opts.serializer !== 'object' || typeof opts.serializer.stringify !== 'function' ||\n    typeof opts.serializer.parse !== 'function')\n   {\n      throw new TypeError(`'clientOptions.serializer' does not conform to the JSON API.`);\n   }\n\n   if (opts.autoConnect !== void 0 && typeof opts.autoConnect !== 'boolean')\n   {\n      throw new TypeError(`'clientOptions.autoConnect' is not a boolean.`);\n   }\n\n   if (opts.autoReconnect !== void 0 && typeof opts.autoReconnect !== 'boolean')\n   {\n      throw new TypeError(`'clientOptions.autoReconnect' is not a boolean.`);\n   }\n\n   if (opts.connectTimeout !== void 0 && (!Number.isInteger(opts.connectTimeout) || opts.connectTimeout < 0))\n   {\n      throw new TypeError(`'clientOptions.connectTimeout' is not an integer or < 0.`);\n   }\n\n   if (opts.messageTimeout !== void 0 && (!Number.isInteger(opts.messageTimeout) || opts.messageTimeout < 0))\n   {\n      throw new TypeError(`'clientOptions.messageTimeout' is not an integer or < 0.`);\n   }\n\n   if (opts.reconnectInterval !== void 0 && (!Number.isInteger(opts.reconnectInterval) || opts.reconnectInterval < 0))\n   {\n      throw new TypeError(`'clientOptions.reconnectInterval' is not an integer or < 0.`);\n   }\n\n\n   opts.autoConnect = typeof opts.autoConnect === 'boolean' ? opts.autoConnect : s_DEFAULT_AUTO_CONNECT;\n   opts.autoReconnect = typeof opts.autoReconnect === 'boolean' ? opts.autoReconnect : s_DEFAULT_AUTO_RECONNECT;\n   opts.connectTimeout = opts.connectTimeout || s_DEFAULT_CONNECT_TIMEOUT;\n   opts.messageTimeout = opts.messageTimeout || s_DEFAULT_MESSAGE_TIMEOUT;\n   opts.reconnectInterval = opts.reconnectInterval || s_DEFAULT_RECONNECT_INTERVAL;\n\n   if (opts.trigger !== void 0 && typeof opts.trigger !== 'boolean')\n   {\n      throw new TypeError(`'clientOptions.trigger' is not a boolean.`);\n   }\n\n   opts.trigger = typeof opts.trigger === 'boolean' ? opts.trigger : s_DEFAULT_TRIGGER;\n\n   if (opts.protocol !== void 0 && typeof opts.protocol !== 'string' && !Array.isArray(opts.protocol))\n   {\n      throw new TypeError(`'clientOptions.protocol' is not a string or string[].`);\n   }\n\n   opts.protocol = opts.protocol ? opts.protocol : [];\n\n   // Set URL from parts\n   if (url === void 0)\n   {\n      url = new URL(`${opts.ssl ? 'wss://' : 'ws://'}${opts.host}:${opts.port}${opts.path}`);\n   }\n   else  // Split parts from URL\n   {\n      opts.host = url.hostname;\n      opts.port = Number.parseInt(url.port);\n      opts.path = url.pathname;\n      opts.ssl = url.protocol.startsWith('wss');\n   }\n\n   return {\n      url: url.toString(),\n      host: opts.host,\n      port: opts.port,\n      ssl: opts.ssl,\n      path: opts.path,\n      binaryType: opts.binaryType,\n      serializer: opts.serializer,\n      autoConnect: opts.autoConnect,\n      autoReconnect: opts.autoReconnect,\n      connectTimeout: opts.connectTimeout,\n      messageTimeout: opts.messageTimeout,\n      reconnectInterval: opts.reconnectInterval,\n      protocol: opts.protocol,\n      trigger: opts.trigger\n   };\n}\n","import Eventbus         from '@typhonjs-plugin/eventbus';\n\nimport Queue            from './utils/Queue.js';\nimport setClientOptions from './utils/setClientOptions.js';\n\nconst s_STR_EVENT_CLOSE = 'socket:close';\nconst s_STR_EVENT_ERROR = 'socket:error';\nconst s_STR_EVENT_MESSAGE_IN = 'socket:message:in';\nconst s_STR_EVENT_SOCKET_OPEN = 'socket:open';\n\n/**\n * Provides a socket connection and forwarding of data via Eventbus events.\n */\nexport default class AbstractWSClient extends Eventbus\n{\n   /**\n    * The parsed client options.\n    *\n    * @type {ClientOptions}\n    */\n   #clientOptions;\n\n   /**\n    * Stores the connection status. The default message queue consumer implementation checks for 'connected' status.\n    *\n    * @type {boolean}\n    */\n   #connected = false;\n\n   /**\n    * Provides a default single consumer message queue.\n    *\n    * @type {Queue}\n    */\n   #queue;\n\n   /**\n    * @type {WebSocket}\n    */\n   #socket;\n\n   /**\n    * @type {Function|WebSocket}\n    *\n    * @private\n    */\n   #WebSocketCtor;\n\n   /**\n    * Some WebSocket implementations may take an implementation specific options object as a third parameter.\n    *\n    * @type {WSOptions}\n    */\n   #wsOptions;\n\n   /**\n    * Creates the socket.\n    *\n    * @param {Function|WebSocket}   WebSocketCtor - The constructor for the WebSocket implementation.\n    *\n    * @param {NewClientOptions}     [clientOptions] - Defines the options for a WebSocket client.\n    *\n    * @param {WSOptions}            [wsOptions] - On Node `ws` is the WebSocket implementation. This object is\n    *                                             passed to the `ws` WebSocket.\n    */\n   constructor(WebSocketCtor, clientOptions = void 0, wsOptions = void 0)\n   {\n      super();\n\n      this.#WebSocketCtor = WebSocketCtor;\n\n      if (clientOptions !== void 0)\n      {\n         this.#clientOptions = setClientOptions(clientOptions);\n      }\n\n      if (wsOptions !== void 0 && typeof wsOptions !== 'object')\n      {\n         throw new TypeError(`'wsOptions' is not an object.`);\n      }\n\n      if (wsOptions !== void 0)\n      {\n         this.#wsOptions = wsOptions;\n      }\n\n      this.#queue = new Queue((message) =>\n      {\n         if (this.#connected) { this.send(message); return true; }\n         else { return false; }\n      });\n\n      // Potentially schedule auto connection\n      if (this.#clientOptions && this.#clientOptions.autoConnect)\n      {\n         setTimeout(this.connect.bind(this), 0);\n      }\n   }\n\n   /**\n    * Connects the socket with potentially new client options.\n    *\n    * The `open`, `error` and `close` events are simply proxy-ed to `_socket`. The `message` event is instead parsed\n    * into a js object (if possible) and then passed as a parameter of the `message:in` event.\n    *\n    * @param {object}            options - Optional parameters.\n    *\n    * @param {NewClientOptions}  [options.clientOptions] - Defines the options for a WebSocket client.\n    *\n    * @param {WSOptions}         [options.wsOptions] - On Node `ws` is the WebSocket implementation. This object is\n    *                                                  passed to the `ws` WebSocket.\n    *\n    * @param {number}            [options.timeout] - Indicates a timeout in ms for connection attempt.\n    *\n    * @returns {Promise<void|object>} A Promise resolved when connected or rejected with an error / timeout.\n    */\n   async connect({ clientOptions = void 0, wsOptions = void 0, timeout = void 0 } = {})\n   {\n      if (this.#socket)\n      {\n         return Promise.reject({\n            message: 'WSClient [connect] already created WebSocket.',\n            type: 'error'\n         });\n      }\n\n      if (clientOptions !== void 0)\n      {\n         this.#clientOptions = setClientOptions(clientOptions);\n      }\n\n      if (wsOptions !== void 0 && typeof wsOptions !== 'object')\n      {\n         throw new TypeError(`'wsOptions' is not an object.`);\n      }\n\n      if (wsOptions !== void 0)\n      {\n         this.#wsOptions = wsOptions;\n      }\n\n      if (typeof this.#clientOptions !== 'object')\n      {\n         return Promise.reject({\n            message: `WSClient [connect] 'clientOptions' has not been set.`,\n            type: 'error'\n         });\n      }\n\n      // Assign default timeout if not specified.\n      if (timeout === void 0)\n      {\n         timeout = this.clientOptions.connectTimeout;\n      }\n\n      if (!Number.isInteger(timeout) || timeout < 0)\n      {\n         throw new TypeError(`'timeout' must be a positive integer.`);\n      }\n\n      if (this.#wsOptions !== void 0)\n      {\n         this.#socket = new this.#WebSocketCtor(this.url, this.#clientOptions.protocol, this.#wsOptions);\n      }\n      else\n      {\n         this.#socket = new this.#WebSocketCtor(this.url, this.#clientOptions.protocol);\n      }\n\n      this.#socket.binaryType = this.#clientOptions.binaryType;\n\n      this.#socket.onclose = () =>\n      {\n         this.#connected = false;\n         this.#socket = void 0;\n\n         this.onSocketClose();\n\n         if (this.#clientOptions.trigger) { super.triggerDefer(s_STR_EVENT_CLOSE); }\n\n         if (this.#clientOptions.autoReconnect)\n         {\n            // Schedule a reconnection\n            setTimeout(this.connect.bind(this), this.#clientOptions.reconnectInterval);\n         }\n      };\n\n      this.#socket.onerror = (error) =>\n      {\n         this.onSocketError(error);\n\n         if (this.#clientOptions.trigger) { super.triggerDefer(s_STR_EVENT_ERROR, error); }\n      };\n\n      this.#socket.onmessage = (event) =>\n      {\n         let data;\n\n         try\n         {\n            data = typeof event.data === 'string' ? this.#clientOptions.serializer.parse(event.data) : event.data;\n         }\n         catch (err)\n         {\n            data = event.data;\n         }\n\n         this.onSocketMessage(data);\n\n         if (this.#clientOptions.trigger) { super.triggerDefer(s_STR_EVENT_MESSAGE_IN, data); }\n      };\n\n      this.#socket.onopen = () =>\n      {\n         this.#connected = true;\n\n         this.onSocketOpen();\n\n         if (this.#clientOptions.trigger) { super.triggerDefer(s_STR_EVENT_SOCKET_OPEN); }\n\n         this.#queue.process();\n      };\n\n      return new Promise((resolve, reject) =>\n      {\n         const onTimeout = setTimeout(() =>\n         {\n            reject({ message: 'WSClient [connect] timed out.', type: 'error' });\n         }, timeout);\n\n         const onError = (error) =>\n         {\n            reject(error);\n         }\n\n         const onOpen = () =>\n         {\n            clearTimeout(onTimeout);\n\n            if (this.#socket)\n            {\n               this.#socket.removeEventListener('error', onOpen);\n               this.#socket.removeEventListener('error', onError);\n            }\n\n            resolve();\n         }\n\n         this.#socket.addEventListener('open', onOpen);\n         this.#socket.addEventListener('error', onError);\n      });\n   }\n\n   /**\n    * Disconnects / closes the socket.\n    *\n    * @param {object}   options - Optional parameters.\n    *\n    * @param {number}   [options.code] - A numeric value indicating the status code explaining why the connection is\n    *                                    being closed. If this parameter is not specified, a default value of 1005\n    *                                    is assumed. See the list of status codes of CloseEvent for permitted values.\n    *\n    * @param {string}   [options.reason] - A human-readable string explaining why the connection is closing. This string\n    *                                      must be no longer than 123 bytes of UTF-8 text (not characters).\n    *\n    * @see https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#status_codes\n    *\n    * @returns {Promise<void|object>} A Promise that resolves when socket is closed or rejected with an error.\n    */\n   async disconnect({ code, reason } = {})\n   {\n      let promise;\n\n      if (this.#socket)\n      {\n         promise = new Promise((resolve, reject) =>\n         {\n            this.#socket.addEventListener('close', () =>\n            {\n               resolve();\n            });\n            this.#socket.addEventListener('error', (error) =>\n            {\n               reject(error);\n            });\n         })\n\n         this.#socket.close(code, reason);\n      }\n\n      this.#connected = false;\n\n      this.#queue.empty();\n\n      return promise;\n   }\n\n   /**\n    * Read-only property returns the number of bytes of data that have been queued using calls to send() but not yet\n    * transmitted to the network. This value resets to zero once all queued data has been sent. This value does not\n    * reset to zero when the connection is closed; if you keep calling send(), this will continue to climb.\n    *\n    * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/bufferedAmount\n    * @returns {number} Current buffered amount.\n    */\n   get bufferedAmount() { return this.#socket ? this.#socket.bufferedAmount : 0; }\n\n   /**\n    * @returns {ClientOptions} Current client options\n    */\n   get clientOptions() { return this.#clientOptions; }\n\n   /**\n    * @returns {boolean} Current connected status.\n    */\n   get connected() { return this.#connected; }\n\n   /**\n    * Read-only property returns the extensions selected by the server. This is currently only the empty string or a\n    * list of extensions as negotiated by the connection.\n    *\n    * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/extensions\n    * @returns {string} Server extensions.\n    */\n   get extensions() { return this.#socket ? this.#socket.extensions : ''; }\n\n   /**\n    * Read-only property returns the name of the sub-protocol the server selected; this will be one of the strings\n    * specified in the protocols parameter when creating the WebSocket object, or the empty string if no connection is\n    * established.\n    *\n    * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/protocol\n    * @returns {string} Server sub-protocol.\n    */\n   get protocol() { return this.#socket ? this.#socket.protocol : ''; }\n\n   /**\n    * @returns {Queue} The message queue.\n    */\n   get queue() { return this.#queue; }\n\n   /**\n    * Read-only property returns the current state of the WebSocket connection.\n    *\n    * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/readyState\n    * @returns {number} Current state of WebSocket.\n    */\n   get readyState() { return this.#socket ? this.#socket.readyState : 3; }\n\n   /**\n    * Read-only property returns the absolute URL of the WebSocket as resolved by the constructor.\n    *\n    * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/url\n    * @returns {string} Absolute URL of the WebSocket.\n    */\n   get url()\n   {\n      return this.#socket ? this.#socket.url :\n       this.#clientOptions ? this.#clientOptions.url : '';\n   }\n\n   /**\n    * Any 'ws' options set for Node WebSocket implementation.\n    *\n    * @returns {WSOptions}\n    */\n   get wsOptions() { return this.#wsOptions; }\n\n   /**\n    * 'onclose' direct method callback.\n    */\n   onSocketClose() {}\n\n   /**\n    * 'onerror' direct method callback.\n    *\n    * @param {object}   error - The error event.\n    */\n   onSocketError(error) {}\n\n   /**\n    * 'onmessage' direct method callback.\n    *\n    * @param {*}  data - The data received.\n    */\n   onSocketMessage(data) {}\n\n   /**\n    * 'onopen' direct method callback.\n    */\n   onSocketOpen() {}\n\n   /**\n    * Reconnects the socket with potentially new client options. First disconnects if currently connected.\n    *\n    * @param {object}            options - Optional parameters.\n    *\n    * @param {NewClientOptions}  [options.clientOptions] - Defines the options for a WebSocket client.\n    *\n    * @param {WSOptions}         [options.wsOptions] - On Node `ws` is the WebSocket implementation. This object is\n    *                                                  passed to the `ws` WebSocket.\n    *\n    * @param {number}            [options.code=1000] - A numeric value indicating the status code explaining why the\n    *                            connection is being closed. If this parameter is not specified, a default value of 1000\n    *                            is assumed indicating normal closure. See the list of status codes of CloseEvent for\n    *                            permitted values.\n    *\n    * @param {string}            [options.reason='reconnecting'] - A human-readable string explaining why the connection\n    *                            is closing. This string must be no longer than 123 bytes of UTF-8 text (not characters).\n    *\n    * @param {number}            [options.timeout=5000] - Indicates a timeout in ms for connection attempt.\n    *\n    * @see https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#status_codes\n    * @see https://github.com/websockets/ws/blob/HEAD/doc/ws.md#new-websocketaddress-protocols-options\n    *\n    * @returns {Promise<void|object>} A Promise resolved when reconnected or rejected with an error / timeout.\n    */\n   async reconnect({ clientOptions = void 0, wsOptions = void 0, code = 1000, reason = 'reconnecting', timeout } = {})\n   {\n      if (clientOptions !== void 0)\n      {\n         this.#clientOptions = setClientOptions(clientOptions);\n      }\n\n      if (wsOptions !== void 0 && typeof wsOptions !== 'object')\n      {\n         throw new TypeError(`'wsOptions' is not an object.`);\n      }\n\n      if (wsOptions !== void 0)\n      {\n         this.#wsOptions = wsOptions;\n      }\n\n      await this.disconnect({ code, reason });\n\n      return this.connect({ timeout });\n   }\n\n   /**\n    * Sends an object over the socket.\n    *\n    * @param {object|string|Blob|ArrayBuffer|ArrayBufferView}  data - The data to send.\n    *\n    * @returns {AbstractWSClient} This WSClient instance.\n    */\n   send(data)\n   {\n      if (this.#socket && this.#clientOptions)\n      {\n         this.#socket.send(data.constructor === Object ? this.#clientOptions.serializer.stringify(data) : data);\n      }\n\n      return this;\n   }\n\n   /**\n    * Sends an object over the socket.\n    *\n    * @param {Iterable<object|string|Blob|ArrayBuffer|ArrayBufferView>}  data - An array of data to send.\n    *\n    * @returns {AbstractWSClient} This WSClient instance.\n    */\n   sendAll(data)\n   {\n      if (this.#socket && this.#clientOptions)\n      {\n         for (const entry of data)\n         {\n            this.#socket.send(entry.constructor === Object ? this.#clientOptions.serializer.stringify(entry) : entry);\n         }\n      }\n\n      return this;\n   }\n\n   /**\n    * Sets clientOptions / wsOptions. Most useful when loading options indirectly.\n    *\n    * @param {object}            options - Optional parameters.\n    *\n    * @param {NewClientOptions}  [options.clientOptions] - Defines the options for a WebSocket client.\n    *\n    * @param {WSOptions}         [options.wsOptions] - On Node `ws` is the WebSocket implementation. This object is\n    *                                                  passed to the `ws` WebSocket.\n    */\n   setOptions({ clientOptions = void 0, wsOptions = void 0 } = {})\n   {\n      if (clientOptions !== void 0)\n      {\n         this.#clientOptions = setClientOptions(clientOptions);\n      }\n\n      if (wsOptions !== void 0 && typeof wsOptions !== 'object')\n      {\n         throw new TypeError(`'wsOptions' is not an object.`);\n      }\n\n      if (wsOptions !== void 0)\n      {\n         this.#wsOptions = wsOptions;\n      }\n   }\n}\n","import AbstractWSClient from '../AbstractWSClient.js';\n\n/**\n * Provides the browser version of WSClient. The function overrides provide protection to not set any provided\n * 'wsOptions' as the browser WebSocket implementation doesn't take a 3rd options object parameter.\n */\nexport default class WSClient extends AbstractWSClient\n{\n   /**\n    * @param {NewClientOptions}  [clientOptions] - Defines the options for a WebSocket client.\n    */\n   constructor(clientOptions = void 0)\n   {\n      super(WebSocket, clientOptions); // eslint-disable-line no-undef\n   }\n\n   /**\n    * Connects the socket with potentially new client options.\n    *\n    * The `open`, `error` and `close` events are simply proxy-ed to `_socket`. The `message` event is instead parsed\n    * into a js object (if possible) and then passed as a parameter of the `message:in` event.\n    *\n    * @param {object}            options - Optional parameters.\n    *\n    * @param {NewClientOptions}  [options.clientOptions] - Defines the options for a WebSocket client.\n    *\n    * @param {WSOptions}         [options.wsOptions] - On Node `ws` is the WebSocket implementation. This object is\n    *                                                  passed to the `ws` WebSocket.\n    *\n    * @param {number}            [options.timeout] - Indicates a timeout in ms for connection attempt.\n    *\n    * @returns {Promise<void|object>} A Promise resolved when connected or rejected with an error / timeout.\n    * @override\n    */\n   async connect({ clientOptions = void 0, wsOptions = void 0, timeout = void 0 } = {}) // eslint-disable-line no-unused-vars\n   {\n      return super.connect({ clientOptions, wsOptions: void 0, timeout });\n   }\n\n   /**\n    * Reconnects the socket with potentially new client options. First disconnects if currently connected.\n    *\n    * @param {object}            [options] - Optional parameters.\n    *\n    * @param {NewClientOptions}  [options.clientOptions] - Defines the options for a WebSocket client.\n    *\n    * @param {WSOptions}         [options.wsOptions] - Unused options for browser WebSocket.\n    *\n    * @param {number}            [options.code=1000] - A numeric value indicating the status code explaining why the\n    *                            connection is being closed. If this parameter is not specified, a default value of 1000\n    *                            is assumed indicating normal closure. See the list of status codes of CloseEvent for\n    *                            permitted values.\n    *\n    * @param {string}            [options.reason='reconnecting'] - A human-readable string explaining why the connection\n    *                            is closing. This string must be no longer than 123 bytes of UTF-8 text (not\n    *                            characters).\n    *\n    * @param {number}            [options.timeout=5000] - Indicates a timeout in ms for connection attempt.\n    *\n    * @see https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#status_codes\n    * @see https://github.com/websockets/ws/blob/HEAD/doc/ws.md#new-websocketaddress-protocols-options\n    *\n    * @returns {Promise<void|object>} A Promise resolved when reconnected or rejected with an error / timeout.\n    * @override\n    */\n   async reconnect({ clientOptions = void 0, wsOptions = void 0, code = 1000, reason = 'reconnecting', timeout } = {})  // eslint-disable-line no-unused-vars\n   {\n      return super.reconnect({ clientOptions, wsOptions: void 0, code, reason, timeout });\n   }\n\n   /**\n    * Sets clientOptions / wsOptions. Most useful when loading options indirectly.\n    *\n    * @param {object}            options - Optional parameters.\n    *\n    * @param {NewClientOptions}  [options.clientOptions] - Defines the options for a WebSocket client.\n    *\n    * @param {WSOptions}         [options.wsOptions] - On Node `ws` is the WebSocket implementation. This object is\n    *                                                  passed to the `ws` WebSocket.\n    *\n    * @override\n    */\n   setOptions({ clientOptions = void 0, wsOptions = void 0 } = {})   // eslint-disable-line no-unused-vars\n   {\n      super.setOptions({ clientOptions, wsOptions: void 0 });\n   }\n}\n"],"names":["eventSplitter","eventsAPI","iteratee","events","name","callback","opts","names","i","context","objectKeys","length","test","split","getErrorName","eventbus","object","Object","keys","beforeMap","map","after","count","beforeWrapper","s_BEFORE","apply","this","arguments","_callback","before","result","args","Eventbus","constructor","TypeError","_listeners","_listenId","_listeningTo","options","Number","isInteger","data","isGuarded","console","warn","Utils","JSON","stringify","off","bind","on","regex","RegExp","event","_classPrivateFieldGet","parse","guarded","s_IS_GUARDED","listenTo","obj","s_TRY_CATCH_IS_GUARDED","id","s_UNIQUE_ID","listeningTo","listening","_listening","Listening","error","s_TRY_CATCH_ON","interop","listenToBefore","stopListening","listenToOnce","s_OFF_API","listeners","s_ON_API","ctx","once","ids","trigger","s_RESULTS_TARGET_API","s_TRIGGER_API","s_TRIGGER_EVENTS","s_TRIGGER_ASYNC_EVENTS","Array","isArray","Promise","all","then","results","allResults","pResult","concat","push","triggerDefer","setTimeout","triggerSync","s_TRIGGER_SYNC_EVENTS","listener","cleanup","incrementCount","value","output","handlers","handler","guard","remaining","j","iterateeTarget","resultsType","newArray","objEvents","allEvents","slice","ev","a1","a2","a3","l","call","async","values","filtered","filter","entry","err","idCounter","prefix","Queue","consumer","queue","element","process","pushAll","elements","shift","empty","s_DEFAULT_SERIALIZER","setClientOptions","url","URL","toLowerCase","protocol","match","port","host","ssl","path","startsWith","binaryType","serializer","autoConnect","autoReconnect","connectTimeout","messageTimeout","reconnectInterval","hostname","parseInt","pathname","toString","AbstractWSClient","WebSocketCtor","clientOptions","wsOptions","message","send","connect","timeout","reject","type","onclose","onSocketClose","onerror","onSocketError","onmessage","onSocketMessage","onopen","onSocketOpen","resolve","onTimeout","onError","onOpen","clearTimeout","removeEventListener","addEventListener","code","reason","promise","close","bufferedAmount","extensions","readyState","disconnect","sendAll","setOptions","WSClient","WebSocket","super","reconnect"],"mappings":"4wBAKO,MAAMA,EAAgB,MAoBtB,SAASC,EAAUC,EAAUC,EAAQC,EAAMC,EAAUC,OAE9CC,EAAPC,EAAI,KACJJ,GAAwB,iBAATA,EACnB,UAEOC,GAAuB,YAAaC,YAAQA,EAAKG,UAAsBH,EAAKG,QAAUJ,OACrFE,EAAQG,EAAWN,GAAOI,EAAID,EAAMI,OAAQH,IAE9CL,EAASF,EAAUC,EAAUC,EAAQI,EAAMC,GAAIJ,EAAKG,EAAMC,IAAKF,QAGhE,GAAIF,GAAQJ,EAAcY,KAAKR,OAG5BG,EAAQH,EAAKS,MAAMb,GAAgBQ,EAAID,EAAMI,OAAQH,IAEvDL,EAASD,EAASC,EAAQI,EAAMC,GAAIH,EAAUC,QAMjDH,EAASD,EAASC,EAAQC,EAAMC,EAAUC,UAEtCH,EAUH,SAASW,EAAaC,SAEpBX,EAAOW,EAASX,WACN,KAATA,MAAkBA,MAAW,GAUhC,MAAMM,EAAcM,GAEN,OAAXA,GAAqC,iBAAXA,EAAsB,GAAKC,OAAOC,KAAKF,GAiBpE,SAASG,EAAUC,EAAKhB,EAAMC,EAAUC,SAEtCe,EAAQf,EAAKe,MACbC,EAAQhB,EAAKgB,MAAQ,KAEvBjB,EACJ,OACSkB,EAAgBH,EAAIhB,GAAQoB,EAASF,GAAO,kBAExCjB,EAASoB,MAAMC,KAAMC,cAC5B,KAAQN,EAAMjB,EAAMmB,MAEvBA,EAAcK,UAAYvB,SAEtBe,EAoBV,MAAMI,EAAW,SAASF,EAAOO,EAAQR,OAElCS,SAEG,YAAYC,WAEVT,EAAQ,IAAKQ,EAASD,EAAOJ,MAAMC,KAAMK,IAE3CT,GAAS,IAEND,GAASA,EAAMI,MAAMC,KAAMK,GAC/BV,SACAQ,UAGIC,oCClIE,MAAME,EAuBlBC,YAAY7B,EAAO,qCAfX,4CAiBe,iBAATA,QAA2B,IAAI8B,UAAW,mCAExC9B,QAQR+B,uBAQAC,sBAQAC,oBAoBRR,OAAOP,EAAOlB,EAAMC,EAAUI,EAAkB6B,EAAU,QAElDC,OAAOC,UAAUlB,SAAgB,IAAIY,UAAW,mCAE/CO,EAAO,MACTf,KAAKgB,UAAUtC,EAAMqC,UAEtBE,QAAQC,kCAAkCC,EAAmBnB,wDACPoB,KAAKC,UAAUN,EAAKlC,UACnEmB,WAIJvB,EAAS0C,EAAgBA,EAAiB,GAAIzC,EAAMC,EAAU,CAAEiB,MAAAA,EAAOD,MAAOK,KAAKsB,IAAIC,KAAKvB,cAE9E,iBAATtB,SAAsBK,IAA2CJ,UAErEqB,KAAKwB,GAAG/C,EAAQE,EAAUI,EAAS6B,YAUpCa,eAEFA,KAAsBA,aAAiBC,cAAiB,IAAIlB,UAAW,gCAEtER,WAEDyB,OAEI,MAAM/C,OAAQsB,WAEZyB,EAAMvC,KAAKR,OAEP,MAAMiD,KAASC,UAAalD,QAExB,CAACA,EAAMiD,EAAMhD,SAAUgD,EAAM5C,QAASqC,KAAKS,MAAMT,KAAKC,UAAUM,EAAMf,oBAOhF,MAAMlC,OAAQsB,YAEX,MAAM2B,KAASC,UAAalD,QAExB,CAACA,EAAMiD,EAAMhD,SAAUgD,EAAM5C,QAASqC,KAAKS,MAAMT,KAAKC,UAAUM,EAAMf,qCAahFZ,QAEET,OAAOC,OAAKQ,SAAcf,OAFL,4BAYvBe,eAAuB,MAExBJ,EAAQ,MAEP,MAAMlB,OAAQsB,QAAgBJ,GAASgC,UAAalD,GAAMO,cAExDW,EAYVoB,UAAUtC,EAAMqC,EAAO,WAEpBA,EAAKlC,MAAQ,GACbkC,EAAKe,WAEUX,EAAgBY,EAAchB,EAAMrC,SAAc,CAAED,SAAQuB,UAE7D8B,cAUXL,eAECA,KAAsBA,aAAiBC,cAAiB,IAAIlB,UAAW,gCAEtER,WAEDyB,MAEI,MAAM/C,OAAQsB,QAEZyB,EAAMvC,KAAKR,WAENA,YAMP,MAAMA,OAAQsB,cAEVtB,sBAYLsB,QAmBVgC,SAASC,EAAKvD,EAAMC,OAEZsD,SAAcjC,WAEbe,EAAO,MACTmB,EAAuBD,EAAKvD,EAAMqC,UAEnCE,QAAQC,kCAAkCC,EAAmBnB,4EACaoB,KAAKC,UAAUN,EAAKlC,UACvFmB,WAGJmC,EAAKF,EAAIvB,YAAcuB,EAAIvB,UAAY0B,EAAY,MACnDC,EAAcrC,KAAKW,eAAiBX,KAAKW,aAAe,QAC1D2B,EAAYC,EAAaF,EAAYF,GAIpCG,SAEG5B,YAAcV,KAAKU,UAAY0B,EAAY,MAChDE,EAAYC,EAAaF,EAAYF,GAAM,IAAIK,EAAUxC,KAAMiC,UAI5DQ,EAAQC,EAAeT,EAAKvD,EAAMC,EAAUqB,SAClDuC,SAEIE,QAAeA,SAGfH,EAAUK,SAAWL,EAAUd,GAAG9C,EAAMC,GAErCqB,KAgBV4C,eAAehD,EAAOqC,EAAKvD,EAAMC,OAEzBkC,OAAOC,UAAUlB,SAAgB,IAAIY,UAAW,mCAG/C/B,EAAS0C,EAAgBA,EAAiB,GAAIzC,EAAMC,EAAU,CACjEiB,MAAAA,EACAD,MAAOK,KAAK6C,cAActB,KAAKvB,KAAMiC,YAGjCjC,KAAKgC,SAASC,EAAKxD,GAc7BqE,aAAab,EAAKvD,EAAMC,SAGfF,EAAS0C,EAAgBA,EAAiB,GAAIzC,EAAMC,EAAU,CACjEiB,MAAO,EACPD,MAAOK,KAAK6C,cAActB,KAAKvB,KAAMiC,YAGjCjC,KAAKgC,SAASC,EAAKxD,GAmC7B6C,IAAI5C,EAAMC,EAAmBI,YAErBiB,kBAEUmB,EAAgB4B,IAAW/C,QAActB,EAAMC,EAAU,CAAEI,QAAAA,EAASiE,UAAWhD,KAAKS,cAE5FT,MAJqBA,KA4C/BwB,GAAG9C,EAAMC,EAAUI,EAAkB6B,EAAU,OAE7B,MAAXA,GAAmBA,EAAQL,cAAgBhB,aAEtC,IAAIiB,UAAW,8CAGlBO,EAAO,UACTf,KAAKgB,UAAUtC,EAAMqC,IAEtBE,QAAQC,kCAAkCC,EAAmBnB,oDACXoB,KAAKC,UAAUN,EAAKlC,UAC/DmB,gBAGKmB,EAAgB8B,EAAUrB,WAAgB,GAAIlD,EAAMC,EAAU,CAC1EI,QAAAA,EACAmE,IAAKlD,KACLY,QAAAA,EACA0B,UAAWC,KAGVA,KAEiBvC,KAAKS,aAAeT,KAAKS,WAAa,KAC9C8B,EAAWJ,IAAMI,EAG3BA,EAAWI,YAGP3C,MAkBVmD,KAAKzE,EAAMC,EAAUI,EAAkB6B,EAAU,UAExCG,EAAO,MACTf,KAAKgB,UAAUtC,EAAMqC,UAEtBE,QAAQC,kCAAkCC,EAAmBnB,sDACToB,KAAKC,UAAUN,EAAKlC,UACjEmB,WAIJvB,EAAS0C,EAAgBA,EAAiB,GAAIzC,EAAMC,EAAU,CAAEiB,MAAO,EAAGD,MAAOK,KAAKsB,IAAIC,KAAKvB,cAEjF,iBAATtB,SAAsBK,IAA2CJ,UAErEqB,KAAKwB,GAAG/C,EAAQE,EAAUI,EAAS6B,GAqB7CiC,cAAcZ,EAAKvD,EAAeC,SAEzB0D,EAAcrC,KAAKW,iBACpB0B,SAAsBrC,WAErBoD,EAAMnB,EAAM,CAACA,EAAIvB,WAAaS,EAAiBkB,OAEhD,IAAIvD,EAAI,EAAGA,EAAIsE,EAAInE,OAAQH,IAChC,OACSwD,EAAYD,EAAYe,EAAItE,QAG7BwD,QAELA,EAAUL,IAAIX,IAAI5C,EAAMC,EAAUqB,MAE9BsC,EAAUK,SAAWL,EAAUhB,IAAI5C,EAAMC,UAGzCqB,KAaVqD,QAAQ3E,KAAS2B,YAETL,SAELsD,EAAqBC,EAAeC,IAAkBxD,QAActB,SAAc2B,GAE3EL,MAJqBA,wBAkBZtB,KAAS2B,SAEpBL,qBAECI,EAASkD,EAAqBC,EAAeE,IAAwBzD,QAActB,SAAc2B,mBAGnGD,EAGCsD,MAAMC,QAAQvD,GAIZwD,QAAQC,IAAIzD,GAAQ0D,MAAMC,QAE1BC,EAAa,OAEZ,MAAMC,KAAWF,EAEfL,MAAMC,QAAQM,GAEfD,EAAaA,EAAWE,OAAOD,YAEzBA,GAEND,EAAWG,KAAKF,UAIfD,EAAW/E,OAAS,EAAI+E,EAAmC,IAAtBA,EAAW/E,OAAe+E,EAAW,aApB/C5D,SAiCxCgE,aAAa1F,KAAS2B,UAEnBgE,YAAW,UAAahB,QAAQ3E,KAAS2B,KAAU,GAE5CL,KAaVsE,YAAY5F,KAAS2B,QAEbL,eAEEsD,EAAqBC,EAAegB,IAAuBvE,QAActB,SAAc2B,IAWpG,IAAIkC,0FAKJ,MAAMC,EAkCHjC,YAAYiE,EAAUvC,oOAFb,aAIKuC,EAAS9D,oBACH8D,YACLvC,gBAKfwC,iBAEU7C,UAAejB,aAAaiB,UAAUlB,aACxCV,gBAAwB4B,UAAUnB,aAAWT,2BAGnCA,+BAEKA,2BAEJA,QAEnB0E,wCAaAlD,GAAG9C,EAAMC,EAAUI,mBAEDoC,EAAgB8B,EAAUrB,WAAgB,GAAIlD,EAAMC,EACnE,CACGI,QAAAA,EACAmE,IAAKlD,KACLY,QAAS,GACT0B,UAAWtC,QAGPA,KAWVsB,IAAI5C,EAAMC,OAEH8F,IAEAzE,kBAEcmB,EAAgB4B,IAAW/C,QAActB,EAAMC,EAAU,CACrEI,eACAiE,oBAEHyB,KAAWzE,iCAKXyE,EAA0B,IAAhB7C,WAGT6C,QAAgBA,sBAQXE,MAGY,kBAAVA,QAA6B,IAAInE,UAAW,qCACvCmE,IAkBtB,MAAM5C,EAAe,CAAC6C,EAAQlG,EAAMC,EAAUC,WAErCH,EAASG,EAAKH,UAEhBA,EACJ,OACSoG,EAAWpG,EAAOC,MAEpBgF,MAAMC,QAAQkB,OAEV,MAAMC,KAAWD,KAEfC,EAAQlE,QAAQmE,aAEhBH,EAAO/F,MAAMsF,KAAKzF,GAClBkG,EAAO9C,WACA8C,SAMbA,GAgBJ7B,EAAY,CAACtE,EAAQC,EAAMC,EAAUC,SAGnCH,eAECM,EAAUH,EAAKG,QAASiE,EAAYpE,EAAKoE,cACpCnE,EAAPC,EAAI,KAGHJ,GAASK,GAAYJ,OAS1BE,EAAQH,EAAO,CAACA,GAAQyC,EAAiB1C,GAElCK,EAAID,EAAMI,OAAQH,IACzB,OAES+F,EAAWpG,EADjBC,EAAOG,EAAMC,QAIR+F,cAGCG,EAAY,OACb,IAAIC,EAAI,EAAGA,EAAIJ,EAAS5F,OAAQgG,IACrC,OACSH,EAAUD,EAASI,MACrBtG,GAAYA,IAAamG,EAAQnG,UAAYA,IAAamG,EAAQnG,SAASuB,WAC9EnB,GAAWA,IAAY+F,EAAQ/F,QAE7BiG,EAAUb,KAAKW,OAGlB,OACSxC,EAAYwC,EAAQxC,UACtBA,GAAaA,EAAUhB,IAAI5C,EAAMC,IAKvCqG,EAAU/F,OAEXR,EAAOC,GAAQsG,SAIRvG,EAAOC,UAIbD,MA7CCI,EAAQsC,EAAiB6B,GAAYlE,EAAID,EAAMI,OAAQH,IAEzDkE,EAAUnE,EAAMC,IAAI2F,WA2DvBxB,EAAW,CAACxE,EAAQC,EAAMC,EAAUC,QAEnCD,EACJ,OACSkG,EAAWpG,EAAOC,KAAUD,EAAOC,GAAQ,IAC3CK,EAAUH,EAAKG,QAASmE,EAAMtE,EAAKsE,IAAKZ,EAAY1D,EAAK0D,UAGzD1B,EAAUQ,KAAKS,MAAMT,KAAKC,UAAUzC,EAAKgC,UAG/CA,EAAQmE,eAAQnE,EAAQmE,OAA6C,kBAAlBnE,EAAQmE,OAAsBnE,EAAQmE,MAErFzC,GAAaA,EAAUoC,iBAE3BG,EAASV,KAAK,CAAExF,SAAAA,EAAUI,QAAAA,EAASmE,IAAKnE,GAAWmE,EAAKtC,QAAAA,EAAS0B,UAAAA,WAE7D7D,GAqBJ6E,EAAuB,CAAC9E,EAAU0G,EAAgBzG,EAAQC,EAAMC,EAAUC,SAEzEmF,EACOlF,EAAPC,EAAI,KAIJJ,GAAQyC,EAAoBjC,KAAKR,OAG7BG,EAAQH,EAAKS,MAAMgC,GAAsBrC,EAAID,EAAMI,OAAQH,IAChE,OACSsB,EAAS5B,EAAS0G,EAAgBzG,EAAQI,EAAMC,GAAIH,EAAUC,GAG9DuG,EAAczB,MAAMC,QAAQI,GAAW,WAAIA,EAAqB,EAAI,KAGtEL,MAAMC,QAAQvD,UAEP+E,QAEA,EAEFpB,EAAU3D,aAER,EAEF2D,EAAU,CAACA,GAASG,OAAO9D,cAEzB,EAEF2D,EAAUA,EAAQG,OAAO9D,QAI7B,YAAIA,SAEE+E,QAEA,EAEFpB,EAAU3D,aAER,SAEIgF,EAAW,CAACrB,GAClBqB,EAASjB,KAAK/D,GACd2D,EAAUqB,aAGR,EAEFrB,EAAQI,KAAK/D,SASzB2D,EAAUvF,EAAS0G,EAAgBzG,EAAQC,EAAMC,EAAUC,UAGvDmF,GAkBJR,EAAgB,CAAC2B,EAAgBG,EAAW3G,EAAMC,EAAU0B,SAE3DD,KAEAiF,EACJ,OACS5G,EAAS4G,EAAU3G,OACrB4G,EAAYD,EAAUxB,IACtBpF,GAAU6G,IAAaA,EAAYA,EAAUC,SAC7C9G,IAAU2B,EAAS8E,EAAezG,EAAQ4B,IAC1CiF,IAAalF,EAAS8E,EAAeI,EAAW,CAAC5G,GAAMwF,OAAO7D,YAG9DD,GAWJoD,EAAmB,CAAC/E,EAAQ4B,SAE3BmF,EAAI1G,GAAK,QACP2G,EAAKpF,EAAK,GAAIqF,EAAKrF,EAAK,GAAIsF,EAAKtF,EAAK,GAAIuF,EAAInH,EAAOQ,cAEnDoB,EAAKpB,aAEL,SACOH,EAAI8G,IAAMJ,EAAK/G,EAAOK,IAAIH,SAASkH,KAAKL,EAAGtC,iBAElD,SACOpE,EAAI8G,IAAMJ,EAAK/G,EAAOK,IAAIH,SAASkH,KAAKL,EAAGtC,IAAKuC,eAEvD,SACO3G,EAAI8G,IAAMJ,EAAK/G,EAAOK,IAAIH,SAASkH,KAAKL,EAAGtC,IAAKuC,EAAIC,eAE3D,SACO5G,EAAI8G,IAAMJ,EAAK/G,EAAOK,IAAIH,SAASkH,KAAKL,EAAGtC,IAAKuC,EAAIC,EAAIC,yBAGxD7G,EAAI8G,IAAMJ,EAAK/G,EAAOK,IAAIH,SAASoB,MAAMyF,EAAGtC,IAAK7C,YAkB7DoD,EAAyBqC,MAAOrH,EAAQ4B,SAEvCmF,EAAI1G,GAAK,QACP2G,EAAKpF,EAAK,GAAIqF,EAAKrF,EAAK,GAAIsF,EAAKtF,EAAK,GAAIuF,EAAInH,EAAOQ,OAErD8E,EAAU,UAER1D,EAAKpB,aAEL,SACOH,EAAI8G,GACb,OACSxF,GAAUoF,EAAK/G,EAAOK,IAAIH,SAASkH,KAAKL,EAAGtC,cAG7C9C,GAAqB2D,EAAQI,KAAK/D,cAIvC,SACOtB,EAAI8G,GACb,OACSxF,GAAUoF,EAAK/G,EAAOK,IAAIH,SAASkH,KAAKL,EAAGtC,IAAKuC,YAGlDrF,GAAqB2D,EAAQI,KAAK/D,cAIvC,SACOtB,EAAI8G,GACb,OACSxF,GAAUoF,EAAK/G,EAAOK,IAAIH,SAASkH,KAAKL,EAAGtC,IAAKuC,EAAIC,YAGtDtF,GAAqB2D,EAAQI,KAAK/D,cAIvC,SACOtB,EAAI8G,GACb,OACSxF,GAAUoF,EAAK/G,EAAOK,IAAIH,SAASkH,KAAKL,EAAGtC,IAAKuC,EAAIC,EAAIC,YAG1DvF,GAAqB2D,EAAQI,KAAK/D,wBAKhCtB,EAAI8G,GACb,OACSxF,GAAUoF,EAAK/G,EAAOK,IAAIH,SAASoB,MAAMyF,EAAGtC,IAAK7C,YAGnDD,GAAqB2D,EAAQI,KAAK/D,WAMxC2D,EAAQ9E,OAAS,EAAI2E,QAAQC,IAAIE,GAASD,MAAMiC,UAE9CC,EAAWD,EAAOE,QAAQC,YAAUA,WAClCF,EAAS/G,aAET,cACA,SAAU+G,EAAS,kBACRA,MAEE,IAAnBjC,EAAQ9E,OAAe8E,EAAQ,WAcjCQ,EAAwB,CAAC9F,EAAQ4B,SAEhCmF,EAAI1G,GAAK,QACP2G,EAAKpF,EAAK,GAAIqF,EAAKrF,EAAK,GAAIsF,EAAKtF,EAAK,GAAIuF,EAAInH,EAAOQ,OAErD8E,EAAU,UAER1D,EAAKpB,aAEL,SACOH,EAAI8G,GACb,OACSxF,GAAUoF,EAAK/G,EAAOK,IAAIH,SAASkH,KAAKL,EAAGtC,cAG7C9C,GAAqB2D,EAAQI,KAAK/D,cAGvC,SACOtB,EAAI8G,GACb,OACSxF,GAAUoF,EAAK/G,EAAOK,IAAIH,SAASkH,KAAKL,EAAGtC,IAAKuC,YAGlDrF,GAAqB2D,EAAQI,KAAK/D,cAGvC,SACOtB,EAAI8G,GACb,OACSxF,GAAUoF,EAAK/G,EAAOK,IAAIH,SAASkH,KAAKL,EAAGtC,IAAKuC,EAAIC,YAGtDtF,GAAqB2D,EAAQI,KAAK/D,cAGvC,SACOtB,EAAI8G,GACb,OACSxF,GAAUoF,EAAK/G,EAAOK,IAAIH,SAASkH,KAAKL,EAAGtC,IAAKuC,EAAIC,EAAIC,YAG1DvF,GAAqB2D,EAAQI,KAAK/D,wBAIhCtB,EAAI8G,GACb,OACSxF,GAAUoF,EAAK/G,EAAOK,IAAIH,SAASoB,MAAMyF,EAAGtC,IAAK7C,YAGnDD,GAAqB2D,EAAQI,KAAK/D,WAMxC2D,EAAQ9E,OAAS,EAAI8E,EAA6B,IAAnBA,EAAQ9E,OAAe8E,EAAQ,WAelE7B,EAAyB,CAACD,EAAKvD,EAAMqC,EAAO,UAE3Ce,eAIK1B,EAAS6B,EAAIjB,UAAUtC,EAAMqC,qBACxBX,IAAwB0B,EAAU1B,GAEhD,MAAO+F,GAEJrE,KACAf,EAAKlC,MAAQ,GACbkC,EAAKe,kBAGDA,GAiBJY,EAAiB,CAACT,EAAKvD,EAAMC,EAAUI,SAIvCkD,EAAIT,GAAG9C,EAAMC,EAAUI,GAE1B,MAAOoH,UAEGA,IASb,IAAIC,EAAY,EAShB,MAAMhE,EAAc,CAACiE,EAAS,YAErBlE,EAAM,MAAIiE,SACTC,KAAYA,IAASlE,IAA4BA,GC5uCnC,IAAI7B,EAAS,gBAOP,IAAIA,EAAS,kBAOf,IAAIA,EAAS,gBCvB1B,MAAMgG,EASlB/F,YAAYgG,QAOJA,SAAWA,OAOXC,MAAQ,GAUhBrC,KAAKsC,eAEGD,MAAMrC,KAAKsC,GAETzG,KAAK0G,UAUfC,QAAQC,eAEAJ,MAAMrC,QAAQyC,GAEZ5G,KAAK0G,UAQfA,iBAEGrC,YAAW,KAEkB,IAAtBrE,KAAKwG,MAAMvH,QAEAe,KAAKuG,SAASvG,KAAKwG,MAAM,WAG7BA,MAAMK,aACNH,aAGX,GAEI1G,KAQV8G,oBAEQN,MAAQ,GAENxG,MCzFb,MAQM+G,EAAuB3F,KAWd,SAAS4F,EAAiBpI,MAElCA,MAAAA,QAEK,IAAI4B,UAAW,4CAGJ,iBAAT5B,QAEF,IAAI4B,UAAW,6CAGP,IAAb5B,EAAKqI,KAAsC,iBAAbrI,EAAKqI,OAAsBrI,EAAKqI,eAAeC,WAExE,IAAI1G,UAAW,mDAGpByG,EAA0B,iBAAbrI,EAAKqI,IAAmB,IAAIC,IAAItI,EAAKqI,IAAIE,eAAiBvI,EAAKqI,YAEpE,IAARA,IAAmBA,EAAIG,SAASC,MAAM,eAEjC,IAAI7G,UAAW,uDAGX,IAARyG,IAAmBpG,OAAOC,UAAUlC,EAAK0I,OAAW1I,EAAK0I,KAAO,GAAK1I,EAAK0I,KAAO,YAE7E,IAAI9G,UAAW,qEAGN,IAAd5B,EAAK2I,MAAwC,iBAAd3I,EAAK2I,WAE/B,IAAI/G,UAAW,4CAGxB5B,EAAK2I,KAAO3I,EAAK2I,MAjDG,iBAmDH,IAAb3I,EAAK4I,KAAsC,kBAAb5I,EAAK4I,UAE9B,IAAIhH,UAAW,4CAGxB5B,EAAK4I,IAA0B,kBAAb5I,EAAK4I,KAAoB5I,EAAK4I,SAE9B,IAAd5I,EAAK6I,MAAwC,iBAAd7I,EAAK6I,WAE/B,IAAIjH,UAAW,4CAGxB5B,EAAK6I,KAA4B,iBAAd7I,EAAK6I,KAAoB7I,EAAK6I,KA7D7B,IAgEf7I,EAAK6I,KAAKC,WAAW,OAAQ9I,EAAK6I,KAAQ,IAAG7I,EAAK6I,aAE/B,IAApB7I,EAAK+I,YAAoD,iBAApB/I,EAAK+I,iBAErC,IAAInH,UAAW,uEAGA,IAApB5B,EAAK+I,YAA6C,SAApB/I,EAAK+I,YAA6C,gBAApB/I,EAAK+I,iBAE5D,IAAInH,UAAW,kEAGxB5B,EAAK+I,WAAwC,iBAApB/I,EAAK+I,WAA0B/I,EAAK+I,WAhFlC,OAmF3B/I,EAAKgJ,WAAahJ,EAAKgJ,YAAcb,EAEN,iBAApBnI,EAAKgJ,YAAgE,mBAA9BhJ,EAAKgJ,WAAWvG,WAChC,mBAA1BzC,EAAKgJ,WAAW/F,YAEf,IAAIrB,UAAW,wEAGC,IAArB5B,EAAKiJ,aAAsD,kBAArBjJ,EAAKiJ,kBAEtC,IAAIrH,UAAW,yDAGG,IAAvB5B,EAAKkJ,eAA0D,kBAAvBlJ,EAAKkJ,oBAExC,IAAItH,UAAW,2DAGI,IAAxB5B,EAAKmJ,kBAA+BlH,OAAOC,UAAUlC,EAAKmJ,iBAAmBnJ,EAAKmJ,eAAiB,SAE9F,IAAIvH,UAAW,oEAGI,IAAxB5B,EAAKoJ,kBAA+BnH,OAAOC,UAAUlC,EAAKoJ,iBAAmBpJ,EAAKoJ,eAAiB,SAE9F,IAAIxH,UAAW,oEAGO,IAA3B5B,EAAKqJ,qBAAkCpH,OAAOC,UAAUlC,EAAKqJ,oBAAsBrJ,EAAKqJ,kBAAoB,SAEvG,IAAIzH,UAAW,kEAIxB5B,EAAKiJ,YAA0C,kBAArBjJ,EAAKiJ,aAA4BjJ,EAAKiJ,YAChEjJ,EAAKkJ,cAA8C,kBAAvBlJ,EAAKkJ,eAA8BlJ,EAAKkJ,cACpElJ,EAAKmJ,eAAiBnJ,EAAKmJ,gBAtHI,IAuH/BnJ,EAAKoJ,eAAiBpJ,EAAKoJ,gBArHI,IAsH/BpJ,EAAKqJ,kBAAoBrJ,EAAKqJ,mBApHI,SAsHb,IAAjBrJ,EAAKyE,SAA8C,kBAAjBzE,EAAKyE,cAElC,IAAI7C,UAAW,gDAGxB5B,EAAKyE,QAAkC,kBAAjBzE,EAAKyE,SAAwBzE,EAAKyE,aAElC,IAAlBzE,EAAKwI,UAAgD,iBAAlBxI,EAAKwI,WAA0B1D,MAAMC,QAAQ/E,EAAKwI,gBAEhF,IAAI5G,UAAW,gEAGxB5B,EAAKwI,SAAWxI,EAAKwI,SAAWxI,EAAKwI,SAAW,QAGpC,IAARH,EAEDA,EAAM,IAAIC,IAAK,GAAEtI,EAAK4I,IAAM,SAAW,UAAU5I,EAAK2I,QAAQ3I,EAAK0I,OAAO1I,EAAK6I,SAI/E7I,EAAK2I,KAAON,EAAIiB,SAChBtJ,EAAK0I,KAAOzG,OAAOsH,SAASlB,EAAIK,MAChC1I,EAAK6I,KAAOR,EAAImB,SAChBxJ,EAAK4I,IAAMP,EAAIG,SAASM,WAAW,QAG/B,CACJT,IAAKA,EAAIoB,WACTd,KAAM3I,EAAK2I,KACXD,KAAM1I,EAAK0I,KACXE,IAAK5I,EAAK4I,IACVC,KAAM7I,EAAK6I,KACXE,WAAY/I,EAAK+I,WACjBC,WAAYhJ,EAAKgJ,WACjBC,YAAajJ,EAAKiJ,YAClBC,cAAelJ,EAAKkJ,cACpBC,eAAgBnJ,EAAKmJ,eACrBC,eAAgBpJ,EAAKoJ,eACrBC,kBAAmBrJ,EAAKqJ,kBACxBb,SAAUxI,EAAKwI,SACf/D,QAASzE,EAAKyE,iGCzJL,MAAMiF,UAAyBhI,EAoD3CC,YAAYgI,EAAeC,EAAwBC,oFAtCtC,yKA0CYF,QAEA,IAAlBC,YAEqBxB,EAAiBwB,SAGxB,IAAdC,GAA6C,iBAAdA,QAE1B,IAAIjI,UAAW,sCAGN,IAAdiI,YAEiBA,YAGP,IAAInC,GAAOoC,OAElB1I,eAAwB2I,KAAKD,IAAiB,MAKjD9G,WAAuBA,UAAoBiG,aAE5CxD,WAAWrE,KAAK4I,QAAQrH,KAAKvB,MAAO,kBAqB5BwI,cAAEA,EAAFC,UAA0BA,EAA1BI,QAA8CA,GAAqB,SAE1E7I,eAEM4D,QAAQkF,OAAO,CACnBJ,QAAS,gDACTK,KAAM,kBAIU,IAAlBP,YAEqBxB,EAAiBwB,SAGxB,IAAdC,GAA6C,iBAAdA,QAE1B,IAAIjI,UAAW,yCAGN,IAAdiI,YAEiBA,GAGc,mBAAxBzI,eAED4D,QAAQkF,OAAO,CACnBJ,QAAU,uDACVK,KAAM,kBAKI,IAAZF,IAEDA,EAAU7I,KAAKwI,cAAcT,iBAG3BlH,OAAOC,UAAU+H,IAAYA,EAAU,QAEnC,IAAIrI,UAAW,qDAGA,IAApBoB,mBAEc,MAAI5B,QAAJ,CAAwBA,KAAKiH,IAAKrF,UAAoBwF,WAAUpH,mBAIhE,MAAIA,QAAJ,CAAwBA,KAAKiH,IAAKrF,UAAoBwF,qBAG3DO,WAAa/F,UAAoB+F,qBAEjCqB,QAAU,eAEF,iBACH,QAEVC,gBAEDrH,UAAoByB,eAAiBe,aA7KxB,gBA+KbxC,UAAoBkG,eAGrBzD,WAAWrE,KAAK4I,QAAQrH,KAAKvB,MAAO4B,UAAoBqG,8BAIjDiB,QAAWzG,SAEhB0G,cAAc1G,GAEfb,UAAoByB,eAAiBe,aAzLxB,eAyLwD3B,cAG/D2G,UAAazH,QAEnBZ,MAIDA,EAA6B,iBAAfY,EAAMZ,KAAoBa,UAAoBgG,WAAW/F,MAAMF,EAAMZ,MAAQY,EAAMZ,KAEpG,MAAOoF,GAEJpF,EAAOY,EAAMZ,UAGXsI,gBAAgBtI,GAEjBa,UAAoByB,eAAiBe,aA1MnB,oBA0MwDrD,cAGpEuI,OAAS,eAED,QAEbC,eAED3H,UAAoByB,eAAiBe,aAlNlB,yBAoNXsC,WAGR,IAAI9C,SAAQ,CAAC4F,EAASV,WAEpBW,EAAYpF,YAAW,KAE1ByE,EAAO,CAAEJ,QAAS,gCAAiCK,KAAM,YACzDF,GAEGa,EAAWjH,IAEdqG,EAAOrG,IAGJkH,EAAS,KAEZC,aAAaH,KAETzJ,oBAEY6J,oBAAoB,QAASF,aAC7BE,oBAAoB,QAASH,IAG7CF,eAGUM,iBAAiB,OAAQH,aACzBG,iBAAiB,QAASJ,wBAoB5BK,KAAEA,EAAFC,OAAQA,GAAW,QAE7BC,WAEAjK,UAEDiK,EAAU,IAAIrG,SAAQ,CAAC4F,EAASV,eAEhBgB,iBAAiB,SAAS,KAEpCN,iBAEUM,iBAAiB,SAAUrH,IAErCqG,EAAOrG,mBAIAyH,MAAMH,EAAMC,cAGV,aAENlD,QAELmD,8BAWoBrI,UAAeA,UAAauI,eAAiB,+BAK9CnK,iCAKJA,gCASC4B,UAAeA,UAAawI,WAAa,yBAU3CxI,UAAeA,UAAawF,SAAW,wBAK1CpH,gCAQK4B,UAAeA,UAAayI,WAAa,mBAUzDzI,UAAeA,UAAaqF,IAClCrF,UAAsBA,UAAoBqF,IAAM,4BAQ3BjH,QAKzBiJ,iBAOAE,cAAc1G,IAOd4G,gBAAgBtI,IAKhBwI,iCA2BgBf,cAAEA,EAAFC,UAA0BA,EAA1BsB,KAA8CA,EAAO,IAArDC,OAA2DA,EAAS,eAApEnB,QAAoFA,GAAY,YAEvF,IAAlBL,YAEqBxB,EAAiBwB,SAGxB,IAAdC,GAA6C,iBAAdA,QAE1B,IAAIjI,UAAW,6CAGN,IAAdiI,YAEiBA,SAGfzI,KAAKsK,WAAW,CAAEP,KAAAA,EAAMC,OAAAA,IAEvBhK,KAAK4I,QAAQ,CAAEC,QAAAA,IAUzBF,KAAK5H,UAEEa,aAAgB5B,mBAEJ2I,KAAK5H,EAAKR,cAAgBhB,OAASqC,UAAoBgG,WAAWvG,UAAUN,GAAQA,GAG7Ff,KAUVuK,QAAQxJ,MAEDa,aAAgB5B,YAEZ,MAAMkG,KAASnF,YAEJ4H,KAAKzC,EAAM3F,cAAgBhB,OAASqC,UAAoBgG,WAAWvG,UAAU6E,GAASA,UAIlGlG,KAaVwK,YAAWhC,cAAEA,EAAFC,UAA0BA,GAAuB,YAEnC,IAAlBD,YAEqBxB,EAAiBwB,SAGxB,IAAdC,GAA6C,iBAAdA,QAE1B,IAAIjI,UAAW,sCAGN,IAAdiI,YAEiBA,IC9eZ,MAAMgC,UAAiBnC,EAKnC/H,YAAYiI,SAEHkC,UAAWlC,kBAqBNA,cAAEA,EAAFC,UAA0BA,EAA1BI,QAA8CA,GAAqB,WAEvE8B,MAAM/B,QAAQ,CAAEJ,cAAAA,EAAeC,eAAW,EAAQI,QAAAA,qBA6B5CL,cAAEA,EAAFC,UAA0BA,EAA1BsB,KAA8CA,EAAO,IAArDC,OAA2DA,EAAS,eAApEnB,QAAoFA,GAAY,WAEtG8B,MAAMC,UAAU,CAAEpC,cAAAA,EAAeC,eAAW,EAAQsB,KAAAA,EAAMC,OAAAA,EAAQnB,QAAAA,IAe5E2B,YAAWhC,cAAEA,EAAFC,UAA0BA,GAAuB,UAEnD+B,WAAW,CAAEhC,cAAAA,EAAeC,eAAW"}