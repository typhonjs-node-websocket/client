function t(t,e){return function(t,e){return e.get?e.get.call(t):e.value}(t,n(t,e,"get"))}function e(t,e,o){return function(t,e,n){if(e.set)e.set.call(t,n);else{if(!e.writable)throw new TypeError("attempted to set read only private field");e.value=n}}(t,n(t,e,"set"),o),o}function n(t,e,n){if(!e.has(t))throw new TypeError("attempted to "+n+" private field on non-instance");return e.get(t)}function o(t,e){return function(t,e){return e.get?e.get.call(t):e.value}(t,s(t,e,"get"))}function i(t,e,n){return function(t,e,n){if(e.set)e.set.call(t,n);else{if(!e.writable)throw new TypeError("attempted to set read only private field");e.value=n}}(t,s(t,e,"set"),n),n}function s(t,e,n){if(!e.has(t))throw new TypeError("attempted to "+n+" private field on non-instance");return e.get(t)}const r=/\s+/;function c(t,e,n,o,i){let s,a=0;if(n&&"object"==typeof n){void 0!==o&&"context"in i&&void 0===i.context&&(i.context=o);for(s=l(n);a<s.length;a++)e=c(t,e,s[a],n[s[a]],i)}else if(n&&r.test(n))for(s=n.split(r);a<s.length;a++)e=t(e,s[a],o,i);else e=t(e,n,o,i);return e}function a(t){const e=t.name;return""!==e?`[${e}] `:""}const l=t=>null===t||"object"!=typeof t?[]:Object.keys(t);function h(t,e,n,o){const i=o.after,s=o.count+1;if(n){const o=t[e]=u(s,(function(){return n.apply(this,arguments)}),(()=>{i(e,o)}));o._callback=n}return t}const u=function(t,e,n){let o;return function(...i){return--t>0&&(o=e.apply(this,i)),t<=1&&(n&&n.apply(this,i),n=void 0,e=void 0),o}};var p=new WeakMap,f=new WeakMap;class d{constructor(t=""){if(p.set(this,{writable:!0,value:""}),f.set(this,{writable:!0,value:void 0}),"string"!=typeof t)throw new TypeError("'name' is not a string");i(this,p,t),this._listeners=void 0,this._listenId=void 0,this._listeningTo=void 0}before(t,e,n,o,i={}){if(!Number.isInteger(t))throw new TypeError("'count' is not an integer");const s={};if(this.isGuarded(e,s))return console.warn(`@typhonjs-plugin/eventbus ${a(this)}- before() failed as event name(s) are guarded: ${JSON.stringify(s.names)}`),this;const r=c(h,{},e,n,{count:t,after:this.off.bind(this)});return"string"==typeof e&&null==o&&(n=void 0),this.on(r,n,o,i)}*entries(t){if(void 0!==t&&!(t instanceof RegExp))throw new TypeError("'regex' is not a RegExp");if(o(this,f))if(t){for(const e in o(this,f))if(t.test(e))for(const t of o(this,f)[e])yield[e,t.callback,t.context,JSON.parse(JSON.stringify(t.options))]}else for(const t in o(this,f))for(const e of o(this,f)[t])yield[t,e.callback,e.context,JSON.parse(JSON.stringify(e.options))]}get eventCount(){return o(this,f)?Object.keys(o(this,f)).length:0}get callbackCount(){if(!o(this,f))return 0;let t=0;for(const e in o(this,f))t+=o(this,f)[e].length;return t}isGuarded(t,e={}){return e.names=[],e.guarded=!1,c(O,e,t,void 0,{events:o(this,f)}).guarded}*keys(t){if(void 0!==t&&!(t instanceof RegExp))throw new TypeError("'regex' is not a RegExp");if(o(this,f))if(t)for(const e in o(this,f))t.test(e)&&(yield e);else for(const t in o(this,f))yield t}get name(){return o(this,p)}listenTo(t,e,n){if(!t)return this;const o={};if(_(t,e,o))return console.warn(`@typhonjs-plugin/eventbus ${a(this)}- listenTo() failed as event name(s) are guarded for target object: ${JSON.stringify(o.names)}`),this;const i=t._listenId||(t._listenId=R("l")),s=this._listeningTo||(this._listeningTo={});let r=g=s[i];r||(this._listenId||(this._listenId=R("l")),r=g=s[i]=new k(this,t));const c=C(t,e,n,this);if(g=void 0,c)throw c;return r.interop&&r.on(e,n),this}listenToBefore(t,e,n,o){if(!Number.isInteger(t))throw new TypeError("'count' is not an integer");const i=c(h,{},n,o,{count:t,after:this.stopListening.bind(this,e)});return this.listenTo(e,i)}listenToOnce(t,e,n){const o=c(h,{},e,n,{count:1,after:this.stopListening.bind(this,t)});return this.listenTo(t,o)}off(t,e,n){return o(this,f)?(i(this,f,c(E,o(this,f),t,e,{context:n,listeners:this._listeners})),this):this}on(t,e,n,s={}){if(null==s||s.constructor!==Object)throw new TypeError("'options' must be an object literal.");const r={};return this.isGuarded(t,r)?(console.warn(`@typhonjs-plugin/eventbus ${a(this)}- on() failed as event name(s) are guarded: ${JSON.stringify(r.names)}`),this):(i(this,f,c(x,o(this,f)||{},t,e,{context:n,ctx:this,options:s,listening:g})),g&&((this._listeners||(this._listeners={}))[g.id]=g,g.interop=!1),this)}once(t,e,n,o={}){const i={};if(this.isGuarded(t,i))return console.warn(`@typhonjs-plugin/eventbus ${a(this)}- once() failed as event name(s) are guarded: ${JSON.stringify(i.names)}`),this;const s=c(h,{},t,e,{count:1,after:this.off.bind(this)});return"string"==typeof t&&null==n&&(e=void 0),this.on(s,e,n,o)}stopListening(t,e,n){const o=this._listeningTo;if(!o)return this;const i=t?[t._listenId]:l(o);for(let t=0;t<i.length;t++){const s=o[i[t]];if(!s)break;s.obj.off(e,n,this),s.interop&&s.off(e,n)}return this}trigger(t,...e){return o(this,f)?(S(j,I,o(this,f),t,void 0,e),this):this}async triggerAsync(t,...e){if(!o(this,f))return;const n=S(j,W,o(this,f),t,void 0,e);return void 0!==n?Array.isArray(n)?Promise.all(n).then((t=>{let e=[];for(const n of t)Array.isArray(n)?e=e.concat(n):void 0!==n&&e.push(n);return e.length>1?e:1===e.length?e[0]:void 0})):n:void 0}triggerDefer(t,...e){return setTimeout((()=>{this.trigger(t,...e)}),0),this}triggerSync(t,...e){if(o(this,f))return S(j,N,o(this,f),t,void 0,e)}}let g;var y=new WeakMap,b=new WeakMap,v=new WeakMap,w=new WeakMap,m=new WeakMap,T=new WeakMap;class k{constructor(t,e){y.set(this,{writable:!0,value:void 0}),b.set(this,{writable:!0,value:void 0}),v.set(this,{writable:!0,value:void 0}),w.set(this,{writable:!0,value:void 0}),m.set(this,{writable:!0,value:void 0}),T.set(this,{writable:!0,value:0}),i(this,b,t._listenId),i(this,v,t),i(this,w,e),i(this,m,!0)}cleanup(){delete o(this,v)._listeningTo[o(this,w)._listenId],o(this,m)||delete o(this,w)._listeners[o(this,b)]}get id(){return o(this,b)}get interop(){return o(this,m)}get obj(){return o(this,w)}incrementCount(){i(this,T,+o(this,T)+1)}on(t,e,n){return i(this,y,c(x,o(this,y)||{},t,e,{context:n,ctx:this,options:{},listening:this})),this}off(t,e){let n;o(this,m)?(i(this,y,c(E,o(this,y),t,e,{context:void 0,listeners:void 0})),n=!o(this,y)):(i(this,T,+o(this,T)-1),n=0===o(this,T)),n&&this.cleanup()}set interop(t){if("boolean"!=typeof t)throw new TypeError("'value' is not a boolean");i(this,m,t)}}const O=(t,e,n,o)=>{const i=o.events;if(i){const n=i[e];if(Array.isArray(n))for(const o of n)if(o.options.guard)return t.names.push(e),t.guarded=!0,t}return t},E=(t,e,n,o)=>{if(!t)return;const i=o.context,s=o.listeners;let r,c=0;if(e||i||n){for(r=e?[e]:l(t);c<r.length;c++){const o=t[e=r[c]];if(!o)break;const s=[];for(let t=0;t<o.length;t++){const r=o[t];if(n&&n!==r.callback&&n!==r.callback._callback||i&&i!==r.context)s.push(r);else{const t=r.listening;t&&t.off(e,n)}}s.length?t[e]=s:delete t[e]}return t}for(r=l(s);c<r.length;c++)s[r[c]].cleanup()},x=(t,e,n,o)=>{if(n){const i=t[e]||(t[e]=[]),s=o.context,r=o.ctx,c=o.listening,a=JSON.parse(JSON.stringify(o.options));a.guard=void 0!==a.guard&&"boolean"==typeof a.guard&&a.guard,c&&c.incrementCount(),i.push({callback:n,context:s,ctx:s||r,options:a,listening:c})}return t},S=(t,e,n,o,i,s)=>{let c,a,l=0;if(o&&r.test(o))for(a=o.split(r);l<a.length;l++){const o=t(e,n,a[l],i,s),r=Array.isArray(c)?2:void 0!==c?1:0;if(Array.isArray(o))switch(r){case 0:c=o;break;case 1:c=[c].concat(o);break;case 2:c=c.concat(o)}else if(void 0!==o)switch(r){case 0:c=o;break;case 1:{const t=[c];t.push(o),c=t;break}case 2:c.push(o)}}else c=t(e,n,o,i,s);return c},j=(t,e,n,o,i)=>{let s;if(e){const o=e[n];let r=e.all;o&&r&&(r=r.slice()),o&&(s=t(o,i)),r&&(s=t(r,[n].concat(i)))}return s},I=(t,e)=>{let n,o=-1;const i=e[0],s=e[1],r=e[2],c=t.length;switch(e.length){case 0:for(;++o<c;)(n=t[o]).callback.call(n.ctx);return;case 1:for(;++o<c;)(n=t[o]).callback.call(n.ctx,i);return;case 2:for(;++o<c;)(n=t[o]).callback.call(n.ctx,i,s);return;case 3:for(;++o<c;)(n=t[o]).callback.call(n.ctx,i,s,r);return;default:for(;++o<c;)(n=t[o]).callback.apply(n.ctx,e);return}},W=async(t,e)=>{let n,o=-1;const i=e[0],s=e[1],r=e[2],c=t.length,a=[];switch(e.length){case 0:for(;++o<c;){const e=(n=t[o]).callback.call(n.ctx);void 0!==e&&a.push(e)}break;case 1:for(;++o<c;){const e=(n=t[o]).callback.call(n.ctx,i);void 0!==e&&a.push(e)}break;case 2:for(;++o<c;){const e=(n=t[o]).callback.call(n.ctx,i,s);void 0!==e&&a.push(e)}break;case 3:for(;++o<c;){const e=(n=t[o]).callback.call(n.ctx,i,s,r);void 0!==e&&a.push(e)}break;default:for(;++o<c;){const i=(n=t[o]).callback.apply(n.ctx,e);void 0!==i&&a.push(i)}}return a.length>1?Promise.all(a).then((t=>{const e=t.filter((t=>void 0!==t));switch(e.length){case 0:return;case 1:return e[0];default:return e}})):1===a.length?a[0]:void 0},N=(t,e)=>{let n,o=-1;const i=e[0],s=e[1],r=e[2],c=t.length,a=[];switch(e.length){case 0:for(;++o<c;){const e=(n=t[o]).callback.call(n.ctx);void 0!==e&&a.push(e)}break;case 1:for(;++o<c;){const e=(n=t[o]).callback.call(n.ctx,i);void 0!==e&&a.push(e)}break;case 2:for(;++o<c;){const e=(n=t[o]).callback.call(n.ctx,i,s);void 0!==e&&a.push(e)}break;case 3:for(;++o<c;){const e=(n=t[o]).callback.call(n.ctx,i,s,r);void 0!==e&&a.push(e)}break;default:for(;++o<c;){const i=(n=t[o]).callback.apply(n.ctx,e);void 0!==i&&a.push(i)}}return a.length>1?a:1===a.length?a[0]:void 0},_=(t,e,n={})=>{let o=!1;try{const i=t.isGuarded(e,n);"boolean"==typeof i&&(o=i)}catch(t){o=!1,n.names=[],n.guarded=!1}return o},C=(t,e,n,o)=>{try{t.on(e,n,o)}catch(t){return t}};let A=0;const R=(t="")=>{const e=""+ ++A;return t?`${t}${e}`:e};new d("mainEventbus"),new d("pluginEventbus"),new d("testEventbus");class M{constructor(t){this.consumer=t,this.queue=[]}push(t){return this.queue.push(t),this.process()}pushAll(t){return this.queue.push(...t),this.process()}process(){return setTimeout((()=>{0!==this.queue.length&&this.consumer(this.queue[0])&&(this.queue.shift(),this.process())}),0),this}empty(){return this.queue=[],this}}const $=JSON;function L(t){if(null==t)throw new TypeError("'clientOptions' is null or undefined.");if("object"!=typeof t)throw new TypeError("'clientOptions' is not an object.");if(void 0!==t.url&&"string"!=typeof t.url&&!(t.url instanceof URL))throw new TypeError("'clientOptions.url' is not a string or URL.");let e="string"==typeof t.url?new URL(t.url.toLowerCase()):t.url;if(void 0!==e&&!e.protocol.match(/^wss?/))throw new TypeError("'clientOptions.url' is not a WebSocket URL.");if(void 0===e&&!Number.isInteger(t.port)||t.port<0||t.port>65535)throw new TypeError("'clientOptions.port' is not an integer between [0-65535].");if(void 0!==t.host&&"string"!=typeof t.host)throw new TypeError("'clientOptions.host' is not a string.");if(t.host=t.host||"localhost",void 0!==t.ssl&&"boolean"!=typeof t.ssl)throw new TypeError("'clientOptions.ssl' is not a boolean.");if(t.ssl="boolean"==typeof t.ssl&&t.ssl,void 0!==t.path&&"string"!=typeof t.path)throw new TypeError("'clientOptions.path' is not a string.");if(t.path="string"==typeof t.path?t.path:"/",t.path.startsWith("/")||(t.path=`/${t.path}`),void 0!==t.binaryType&&"string"!=typeof t.binaryType)throw new TypeError("'clientOptions.binaryType' must be 'blob' or 'arraybuffer'.");if(void 0!==t.binaryType&&"blob"!==t.binaryType&&"arraybuffer"!==t.binaryType)throw new TypeError("'clientOptions.binaryType' must be 'blob' or 'arraybuffer'.");if(t.binaryType="string"==typeof t.binaryType?t.binaryType:"blob",t.serializer=t.serializer||$,"object"!=typeof t.serializer||"function"!=typeof t.serializer.stringify||"function"!=typeof t.serializer.parse)throw new TypeError("'clientOptions.serializer' does not conform to the JSON API.");if(void 0!==t.autoConnect&&"boolean"!=typeof t.autoConnect)throw new TypeError("'clientOptions.autoConnect' is not a boolean.");if(void 0!==t.autoReconnect&&"boolean"!=typeof t.autoReconnect)throw new TypeError("'clientOptions.autoReconnect' is not a boolean.");if(void 0!==t.connectTimeout&&(!Number.isInteger(t.connectTimeout)||t.connectTimeout<0))throw new TypeError("'clientOptions.connectTimeout' is not an integer or < 0.");if(void 0!==t.messageTimeout&&(!Number.isInteger(t.messageTimeout)||t.messageTimeout<0))throw new TypeError("'clientOptions.messageTimeout' is not an integer or < 0.");if(void 0!==t.reconnectInterval&&(!Number.isInteger(t.reconnectInterval)||t.reconnectInterval<0))throw new TypeError("'clientOptions.reconnectInterval' is not an integer or < 0.");if(t.autoConnect="boolean"==typeof t.autoConnect&&t.autoConnect,t.autoReconnect="boolean"==typeof t.autoReconnect&&t.autoReconnect,t.connectTimeout=t.connectTimeout||5e3,t.messageTimeout=t.messageTimeout||1e4,t.reconnectInterval=t.reconnectInterval||2e3,void 0!==t.trigger&&"boolean"!=typeof t.trigger)throw new TypeError("'clientOptions.trigger' is not a boolean.");if(t.trigger="boolean"!=typeof t.trigger||t.trigger,void 0!==t.protocol&&"string"!=typeof t.protocol&&!Array.isArray(t.protocol))throw new TypeError("'clientOptions.protocol' is not a string or string[].");return t.protocol=t.protocol?t.protocol:[],void 0===e?e=new URL(`${t.ssl?"wss://":"ws://"}${t.host}:${t.port}${t.path}`):(t.host=e.hostname,t.port=Number.parseInt(e.port),t.path=e.pathname,t.ssl=e.protocol.startsWith("wss")),{url:e.toString(),host:t.host,port:t.port,ssl:t.ssl,path:t.path,binaryType:t.binaryType,serializer:t.serializer,autoConnect:t.autoConnect,autoReconnect:t.autoReconnect,connectTimeout:t.connectTimeout,messageTimeout:t.messageTimeout,reconnectInterval:t.reconnectInterval,protocol:t.protocol,trigger:t.trigger}}var J=new WeakMap,z=new WeakMap,q=new WeakMap,P=new WeakMap,D=new WeakMap,G=new WeakMap;class U extends d{constructor(n,o,i){if(super(),J.set(this,{writable:!0,value:void 0}),z.set(this,{writable:!0,value:!1}),q.set(this,{writable:!0,value:void 0}),P.set(this,{writable:!0,value:void 0}),D.set(this,{writable:!0,value:void 0}),G.set(this,{writable:!0,value:void 0}),e(this,D,n),void 0!==o&&e(this,J,L(o)),void 0!==i&&"object"!=typeof i)throw new TypeError("'wsOptions' is not an object.");void 0!==i&&e(this,G,i),e(this,q,new M((e=>!!t(this,z)&&(this.send(e),!0)))),t(this,J)&&t(this,J).autoConnect&&setTimeout(this.connect.bind(this),0)}async connect({clientOptions:n,wsOptions:o,timeout:i}={}){if(t(this,P))return Promise.reject({message:"WSClient [connect] already created WebSocket.",type:"error"});if(void 0!==n&&e(this,J,L(n)),void 0!==o&&"object"!=typeof o)throw new TypeError("'wsOptions' is not an object.");if(void 0!==o&&e(this,G,o),"object"!=typeof t(this,J))return Promise.reject({message:"WSClient [connect] 'clientOptions' has not been set.",type:"error"});if(void 0===i&&(i=this.clientOptions.connectTimeout),!Number.isInteger(i)||i<0)throw new TypeError("'timeout' must be a positive integer.");return void 0!==t(this,G)?e(this,P,new(t(this,D))(this.url,t(this,J).protocol,t(this,G))):e(this,P,new(t(this,D))(this.url,t(this,J).protocol)),t(this,P).binaryType=t(this,J).binaryType,t(this,P).onclose=()=>{e(this,z,!1),e(this,P,void 0),this.onSocketClose(),t(this,J).trigger&&super.triggerDefer("socket:close"),t(this,J).autoReconnect&&setTimeout(this.connect.bind(this),t(this,J).reconnectInterval)},t(this,P).onerror=e=>{this.onSocketError(e),t(this,J).trigger&&super.triggerDefer("socket:error",e)},t(this,P).onmessage=e=>{let n;try{n="string"==typeof e.data?t(this,J).serializer.parse(e.data):e.data}catch(t){n=e.data}this.onSocketMessage(n),t(this,J).trigger&&super.triggerDefer("socket:message:in",n)},t(this,P).onopen=()=>{e(this,z,!0),this.onSocketOpen(),t(this,J).trigger&&super.triggerDefer("socket:open"),t(this,q).process()},new Promise(((e,n)=>{const o=setTimeout((()=>{n({message:"WSClient [connect] timed out.",type:"error"})}),i),s=t=>{n(t)},r=()=>{clearTimeout(o),t(this,P)&&(t(this,P).removeEventListener("error",r),t(this,P).removeEventListener("error",s)),e()};t(this,P).addEventListener("open",r),t(this,P).addEventListener("error",s)}))}async disconnect({code:n,reason:o}={}){let i;return t(this,P)&&(i=new Promise(((e,n)=>{t(this,P).addEventListener("close",(()=>{e()})),t(this,P).addEventListener("error",(t=>{n(t)}))})),t(this,P).close(n,o)),e(this,z,!1),t(this,q).empty(),i}get bufferedAmount(){return t(this,P)?t(this,P).bufferedAmount:0}get clientOptions(){return t(this,J)}get connected(){return t(this,z)}get extensions(){return t(this,P)?t(this,P).extensions:""}get protocol(){return t(this,P)?t(this,P).protocol:""}get queue(){return t(this,q)}get readyState(){return t(this,P)?t(this,P).readyState:3}get url(){return t(this,P)?t(this,P).url:t(this,J)?t(this,J).url:""}get wsOptions(){return t(this,G)}onSocketClose(){}onSocketError(t){}onSocketMessage(t){}onSocketOpen(){}async reconnect({clientOptions:t,wsOptions:n,code:o=1e3,reason:i="reconnecting",timeout:s}={}){if(void 0!==t&&e(this,J,L(t)),void 0!==n&&"object"!=typeof n)throw new TypeError("'wsOptions' is not an object.");return void 0!==n&&e(this,G,n),await this.disconnect({code:o,reason:i}),this.connect({timeout:s})}send(e){return t(this,P)&&t(this,J)&&t(this,P).send(e.constructor===Object?t(this,J).serializer.stringify(e):e),this}sendAll(e){if(t(this,P)&&t(this,J))for(const n of e)t(this,P).send(n.constructor===Object?t(this,J).serializer.stringify(n):n);return this}setOptions({clientOptions:t,wsOptions:n}={}){if(void 0!==t&&e(this,J,L(t)),void 0!==n&&"object"!=typeof n)throw new TypeError("'wsOptions' is not an object.");void 0!==n&&e(this,G,n)}}class B extends U{constructor(t){super(WebSocket,t)}async connect({clientOptions:t,wsOptions:e,timeout:n}={}){return super.connect({clientOptions:t,wsOptions:void 0,timeout:n})}async reconnect({clientOptions:t,wsOptions:e,code:n=1e3,reason:o="reconnecting",timeout:i}={}){return super.reconnect({clientOptions:t,wsOptions:void 0,code:n,reason:o,timeout:i})}setOptions({clientOptions:t,wsOptions:e}={}){super.setOptions({clientOptions:t,wsOptions:void 0})}}export{M as Queue,B as WSClient};
//# sourceMappingURL=WSClient.js.map
