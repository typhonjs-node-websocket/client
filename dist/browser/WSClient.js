function t(t,e){return function(t,e){return e.get?e.get.call(t):e.value}(t,n(t,e,"get"))}function e(t,e,i){return function(t,e,n){if(e.set)e.set.call(t,n);else{if(!e.writable)throw new TypeError("attempted to set read only private field");e.value=n}}(t,n(t,e,"set"),i),i}function n(t,e,n){if(!e.has(t))throw new TypeError("attempted to "+n+" private field on non-instance");return e.get(t)}function i(t,e){return function(t,e){return e.get?e.get.call(t):e.value}(t,s(t,e,"get"))}function o(t,e,n){return function(t,e,n){if(e.set)e.set.call(t,n);else{if(!e.writable)throw new TypeError("attempted to set read only private field");e.value=n}}(t,s(t,e,"set"),n),n}function s(t,e,n){if(!e.has(t))throw new TypeError("attempted to "+n+" private field on non-instance");return e.get(t)}const r=/\s+/;function c(t,e,n,i,o){let s,a=0;if(n&&"object"==typeof n){void 0!==i&&"context"in o&&void 0===o.context&&(o.context=i);for(s=l(n);a<s.length;a++)e=c(t,e,s[a],n[s[a]],o)}else if(n&&r.test(n))for(s=n.split(r);a<s.length;a++)e=t(e,s[a],i,o);else e=t(e,n,i,o);return e}function a(t){const e=t.name;return""!==e?`[${e}] `:""}const l=t=>null===t||"object"!=typeof t?[]:Object.keys(t);function h(t,e,n,i){const o=i.after,s=i.count+1;if(n){const i=t[e]=u(s,(function(){return n.apply(this,arguments)}),(()=>{o(e,i)}));i._callback=n}return t}const u=function(t,e,n){let i;return function(...o){return--t>0&&(i=e.apply(this,o)),t<=1&&(n&&n.apply(this,o),n=void 0,e=void 0),i}};var p=new WeakMap,f=new WeakMap;class d{constructor(t=""){if(p.set(this,{writable:!0,value:""}),f.set(this,{writable:!0,value:void 0}),"string"!=typeof t)throw new TypeError("'name' is not a string");o(this,p,t),this._listeners=void 0,this._listenId=void 0,this._listeningTo=void 0}before(t,e,n,i,o={}){if(!Number.isInteger(t))throw new TypeError("'count' is not an integer");const s={};if(this.isGuarded(e,s))return console.warn(`@typhonjs-plugin/eventbus ${a(this)}- before() failed as event name(s) are guarded: ${JSON.stringify(s.names)}`),this;const r=c(h,{},e,n,{count:t,after:this.off.bind(this)});return"string"==typeof e&&null==i&&(n=void 0),this.on(r,n,i,o)}*entries(t){if(void 0!==t&&!(t instanceof RegExp))throw new TypeError("'regex' is not a RegExp");if(i(this,f))if(t){for(const e in i(this,f))if(t.test(e))for(const t of i(this,f)[e])yield[e,t.callback,t.context,JSON.parse(JSON.stringify(t.options))]}else for(const t in i(this,f))for(const e of i(this,f)[t])yield[t,e.callback,e.context,JSON.parse(JSON.stringify(e.options))]}get eventCount(){return i(this,f)?Object.keys(i(this,f)).length:0}get callbackCount(){if(!i(this,f))return 0;let t=0;for(const e in i(this,f))t+=i(this,f)[e].length;return t}isGuarded(t,e={}){return e.names=[],e.guarded=!1,c(O,e,t,void 0,{events:i(this,f)}).guarded}*keys(t){if(void 0!==t&&!(t instanceof RegExp))throw new TypeError("'regex' is not a RegExp");if(i(this,f))if(t)for(const e in i(this,f))t.test(e)&&(yield e);else for(const t in i(this,f))yield t}get name(){return i(this,p)}listenTo(t,e,n){if(!t)return this;const i={};if(_(t,e,i))return console.warn(`@typhonjs-plugin/eventbus ${a(this)}- listenTo() failed as event name(s) are guarded for target object: ${JSON.stringify(i.names)}`),this;const o=t._listenId||(t._listenId=R("l")),s=this._listeningTo||(this._listeningTo={});let r=g=s[o];r||(this._listenId||(this._listenId=R("l")),r=g=s[o]=new k(this,t));const c=C(t,e,n,this);if(g=void 0,c)throw c;return r.interop&&r.on(e,n),this}listenToBefore(t,e,n,i){if(!Number.isInteger(t))throw new TypeError("'count' is not an integer");const o=c(h,{},n,i,{count:t,after:this.stopListening.bind(this,e)});return this.listenTo(e,o)}listenToOnce(t,e,n){const i=c(h,{},e,n,{count:1,after:this.stopListening.bind(this,t)});return this.listenTo(t,i)}off(t,e,n){return i(this,f)?(o(this,f,c(E,i(this,f),t,e,{context:n,listeners:this._listeners})),this):this}on(t,e,n,s={}){if(null==s||s.constructor!==Object)throw new TypeError("'options' must be an object literal.");const r={};return this.isGuarded(t,r)?(console.warn(`@typhonjs-plugin/eventbus ${a(this)}- on() failed as event name(s) are guarded: ${JSON.stringify(r.names)}`),this):(o(this,f,c(x,i(this,f)||{},t,e,{context:n,ctx:this,options:s,listening:g})),g&&((this._listeners||(this._listeners={}))[g.id]=g,g.interop=!1),this)}once(t,e,n,i={}){const o={};if(this.isGuarded(t,o))return console.warn(`@typhonjs-plugin/eventbus ${a(this)}- once() failed as event name(s) are guarded: ${JSON.stringify(o.names)}`),this;const s=c(h,{},t,e,{count:1,after:this.off.bind(this)});return"string"==typeof t&&null==n&&(e=void 0),this.on(s,e,n,i)}stopListening(t,e,n){const i=this._listeningTo;if(!i)return this;const o=t?[t._listenId]:l(i);for(let t=0;t<o.length;t++){const s=i[o[t]];if(!s)break;s.obj.off(e,n,this),s.interop&&s.off(e,n)}return this}trigger(t,...e){return i(this,f)?(S(j,I,i(this,f),t,void 0,e),this):this}async triggerAsync(t,...e){if(!i(this,f))return;const n=S(j,W,i(this,f),t,void 0,e);return void 0!==n?Array.isArray(n)?Promise.all(n).then((t=>{let e=[];for(const n of t)Array.isArray(n)?e=e.concat(n):void 0!==n&&e.push(n);return e.length>1?e:1===e.length?e[0]:void 0})):n:void 0}triggerDefer(t,...e){return setTimeout((()=>{this.trigger(t,...e)}),0),this}triggerSync(t,...e){if(i(this,f))return S(j,N,i(this,f),t,void 0,e)}}let g;var y=new WeakMap,b=new WeakMap,v=new WeakMap,w=new WeakMap,m=new WeakMap,T=new WeakMap;class k{constructor(t,e){y.set(this,{writable:!0,value:void 0}),b.set(this,{writable:!0,value:void 0}),v.set(this,{writable:!0,value:void 0}),w.set(this,{writable:!0,value:void 0}),m.set(this,{writable:!0,value:void 0}),T.set(this,{writable:!0,value:0}),o(this,b,t._listenId),o(this,v,t),o(this,w,e),o(this,m,!0)}cleanup(){delete i(this,v)._listeningTo[i(this,w)._listenId],i(this,m)||delete i(this,w)._listeners[i(this,b)]}get id(){return i(this,b)}get interop(){return i(this,m)}get obj(){return i(this,w)}incrementCount(){o(this,T,+i(this,T)+1)}on(t,e,n){return o(this,y,c(x,i(this,y)||{},t,e,{context:n,ctx:this,options:{},listening:this})),this}off(t,e){let n;i(this,m)?(o(this,y,c(E,i(this,y),t,e,{context:void 0,listeners:void 0})),n=!i(this,y)):(o(this,T,+i(this,T)-1),n=0===i(this,T)),n&&this.cleanup()}set interop(t){if("boolean"!=typeof t)throw new TypeError("'value' is not a boolean");o(this,m,t)}}const O=(t,e,n,i)=>{const o=i.events;if(o){const n=o[e];if(Array.isArray(n))for(const i of n)if(i.options.guard)return t.names.push(e),t.guarded=!0,t}return t},E=(t,e,n,i)=>{if(!t)return;const o=i.context,s=i.listeners;let r,c=0;if(e||o||n){for(r=e?[e]:l(t);c<r.length;c++){const i=t[e=r[c]];if(!i)break;const s=[];for(let t=0;t<i.length;t++){const r=i[t];if(n&&n!==r.callback&&n!==r.callback._callback||o&&o!==r.context)s.push(r);else{const t=r.listening;t&&t.off(e,n)}}s.length?t[e]=s:delete t[e]}return t}for(r=l(s);c<r.length;c++)s[r[c]].cleanup()},x=(t,e,n,i)=>{if(n){const o=t[e]||(t[e]=[]),s=i.context,r=i.ctx,c=i.listening,a=JSON.parse(JSON.stringify(i.options));a.guard=void 0!==a.guard&&"boolean"==typeof a.guard&&a.guard,c&&c.incrementCount(),o.push({callback:n,context:s,ctx:s||r,options:a,listening:c})}return t},S=(t,e,n,i,o,s)=>{let c,a,l=0;if(i&&r.test(i))for(a=i.split(r);l<a.length;l++){const i=t(e,n,a[l],o,s),r=Array.isArray(c)?2:void 0!==c?1:0;if(Array.isArray(i))switch(r){case 0:c=i;break;case 1:c=[c].concat(i);break;case 2:c=c.concat(i)}else if(void 0!==i)switch(r){case 0:c=i;break;case 1:{const t=[c];t.push(i),c=t;break}case 2:c.push(i)}}else c=t(e,n,i,o,s);return c},j=(t,e,n,i,o)=>{let s;if(e){const i=e[n];let r=e.all;i&&r&&(r=r.slice()),i&&(s=t(i,o)),r&&(s=t(r,[n].concat(o)))}return s},I=(t,e)=>{let n,i=-1;const o=e[0],s=e[1],r=e[2],c=t.length;switch(e.length){case 0:for(;++i<c;)(n=t[i]).callback.call(n.ctx);return;case 1:for(;++i<c;)(n=t[i]).callback.call(n.ctx,o);return;case 2:for(;++i<c;)(n=t[i]).callback.call(n.ctx,o,s);return;case 3:for(;++i<c;)(n=t[i]).callback.call(n.ctx,o,s,r);return;default:for(;++i<c;)(n=t[i]).callback.apply(n.ctx,e);return}},W=async(t,e)=>{let n,i=-1;const o=e[0],s=e[1],r=e[2],c=t.length,a=[];switch(e.length){case 0:for(;++i<c;){const e=(n=t[i]).callback.call(n.ctx);void 0!==e&&a.push(e)}break;case 1:for(;++i<c;){const e=(n=t[i]).callback.call(n.ctx,o);void 0!==e&&a.push(e)}break;case 2:for(;++i<c;){const e=(n=t[i]).callback.call(n.ctx,o,s);void 0!==e&&a.push(e)}break;case 3:for(;++i<c;){const e=(n=t[i]).callback.call(n.ctx,o,s,r);void 0!==e&&a.push(e)}break;default:for(;++i<c;){const o=(n=t[i]).callback.apply(n.ctx,e);void 0!==o&&a.push(o)}}return a.length>1?Promise.all(a).then((t=>{const e=t.filter((t=>void 0!==t));switch(e.length){case 0:return;case 1:return e[0];default:return e}})):1===a.length?a[0]:void 0},N=(t,e)=>{let n,i=-1;const o=e[0],s=e[1],r=e[2],c=t.length,a=[];switch(e.length){case 0:for(;++i<c;){const e=(n=t[i]).callback.call(n.ctx);void 0!==e&&a.push(e)}break;case 1:for(;++i<c;){const e=(n=t[i]).callback.call(n.ctx,o);void 0!==e&&a.push(e)}break;case 2:for(;++i<c;){const e=(n=t[i]).callback.call(n.ctx,o,s);void 0!==e&&a.push(e)}break;case 3:for(;++i<c;){const e=(n=t[i]).callback.call(n.ctx,o,s,r);void 0!==e&&a.push(e)}break;default:for(;++i<c;){const o=(n=t[i]).callback.apply(n.ctx,e);void 0!==o&&a.push(o)}}return a.length>1?a:1===a.length?a[0]:void 0},_=(t,e,n={})=>{let i=!1;try{const o=t.isGuarded(e,n);"boolean"==typeof o&&(i=o)}catch(t){i=!1,n.names=[],n.guarded=!1}return i},C=(t,e,n,i)=>{try{t.on(e,n,i)}catch(t){return t}};let A=0;const R=(t="")=>{const e=""+ ++A;return t?`${t}${e}`:e};new d("mainEventbus"),new d("pluginEventbus"),new d("testEventbus");class M{constructor(t){this.consumer=t,this.queue=[]}push(t){return this.queue.push(t),this.process()}pushAll(t){return this.queue.push(...t),this.process()}process(){return setTimeout((()=>{0!==this.queue.length&&this.consumer(this.queue[0])&&(this.queue.shift(),this.process())}),0),this}empty(){return this.queue=[],this}}const $=JSON;function L(t){if(null==t)throw new TypeError("'clientOptions' is null or undefined.");if("object"!=typeof t)throw new TypeError("'clientOptions' is not an object.");if(void 0!==t.url&&"string"!=typeof t.url&&!(t.url instanceof URL))throw new TypeError("'clientOptions.url' is not a string or URL.");let e="string"==typeof t.url?new URL(t.url.toLowerCase()):t.url;if(void 0!==e&&!e.protocol.match(/^wss?/))throw new TypeError("'clientOptions.url' is not a WebSocket URL.");if(void 0===e&&!Number.isInteger(t.port)||t.port<0||t.port>65535)throw new TypeError("'clientOptions.port' is not an integer between [0-65535].");if(void 0!==t.host&&"string"!=typeof t.host)throw new TypeError("'clientOptions.host' is not a string.");if(t.host=t.host||"localhost",void 0!==t.ssl&&"boolean"!=typeof t.ssl)throw new TypeError("'clientOptions.ssl' is not a boolean.");if(t.ssl="boolean"==typeof t.ssl&&t.ssl,void 0!==t.path&&"string"!=typeof t.path)throw new TypeError("'clientOptions.path' is not a string.");if(t.path="string"==typeof t.path?t.path:"/",t.path.startsWith("/")||(t.path=`/${t.path}`),void 0!==t.binaryType&&"string"!=typeof t.binaryType)throw new TypeError("'clientOptions.binaryType' must be 'blob' or 'arraybuffer'.");if(void 0!==t.binaryType&&"blob"!==t.binaryType&&"arraybuffer"!==t.binaryType)throw new TypeError("'clientOptions.binaryType' must be 'blob' or 'arraybuffer'.");if(t.binaryType="string"==typeof t.binaryType?t.binaryType:"blob",t.serializer=t.serializer||$,"object"!=typeof t.serializer||"function"!=typeof t.serializer.stringify||"function"!=typeof t.serializer.parse)throw new TypeError("'clientOptions.serializer' does not conform to the JSON API.");if(void 0!==t.autoConnect&&"boolean"!=typeof t.autoConnect)throw new TypeError("'clientOptions.autoConnect' is not a boolean.");if(void 0!==t.autoReconnect&&"boolean"!=typeof t.autoReconnect)throw new TypeError("'clientOptions.autoReconnect' is not a boolean.");if(void 0!==t.connectTimeout&&(!Number.isInteger(t.connectTimeout)||t.connectTimeout<0))throw new TypeError("'clientOptions.connectTimeout' is not an integer or < 0.");if(void 0!==t.messageTimeout&&(!Number.isInteger(t.messageTimeout)||t.messageTimeout<0))throw new TypeError("'clientOptions.messageTimeout' is not an integer or < 0.");if(void 0!==t.reconnectInterval&&(!Number.isInteger(t.reconnectInterval)||t.reconnectInterval<0))throw new TypeError("'clientOptions.reconnectInterval' is not an integer or < 0.");if(t.autoConnect="boolean"==typeof t.autoConnect&&t.autoConnect,t.autoReconnect="boolean"==typeof t.autoReconnect&&t.autoReconnect,t.connectTimeout=t.connectTimeout||5e3,t.messageTimeout=t.messageTimeout||1e4,t.reconnectInterval=t.reconnectInterval||2e3,void 0!==t.trigger&&"boolean"!=typeof t.trigger)throw new TypeError("'clientOptions.trigger' is not a boolean.");if(t.trigger="boolean"!=typeof t.trigger||t.trigger,void 0!==t.protocol&&"string"!=typeof t.protocol&&!Array.isArray(t.protocol))throw new TypeError("'clientOptions.protocol' is not a string or string[].");return t.protocol=t.protocol?t.protocol:[],void 0===e?e=new URL(`${t.ssl?"wss://":"ws://"}${t.host}:${t.port}${t.path}`):(t.host=e.hostname,t.port=Number.parseInt(e.port),t.path=e.pathname,t.ssl=e.protocol.startsWith("wss")),{url:e.toString(),host:t.host,port:t.port,ssl:t.ssl,path:t.path,binaryType:t.binaryType,serializer:t.serializer,autoConnect:t.autoConnect,autoReconnect:t.autoReconnect,connectTimeout:t.connectTimeout,messageTimeout:t.messageTimeout,reconnectInterval:t.reconnectInterval,protocol:t.protocol,trigger:t.trigger}}var z=new WeakMap,J=new WeakMap,q=new WeakMap,P=new WeakMap,D=new WeakMap,G=new WeakMap;class U extends d{constructor(n,i,o){if(super(),z.set(this,{writable:!0,value:void 0}),J.set(this,{writable:!0,value:!1}),q.set(this,{writable:!0,value:void 0}),P.set(this,{writable:!0,value:void 0}),D.set(this,{writable:!0,value:void 0}),G.set(this,{writable:!0,value:void 0}),e(this,D,n),void 0!==i&&e(this,z,L(i)),void 0!==o&&"object"!=typeof o)throw new TypeError("'wsOptions' is not an object.");void 0!==o&&e(this,G,o),e(this,q,new M((e=>!!t(this,J)&&(this.send(e),!0)))),t(this,z)&&t(this,z).autoConnect&&setTimeout(this.connect.bind(this),0),this.onInitialize()}async connect({clientOptions:n,wsOptions:i,timeout:o}={}){if(t(this,P))return Promise.reject({message:"WSClient [connect] already created WebSocket.",type:"error"});if(void 0!==n&&e(this,z,L(n)),void 0!==i&&"object"!=typeof i)throw new TypeError("'wsOptions' is not an object.");if(void 0!==i&&e(this,G,i),"object"!=typeof t(this,z))return Promise.reject({message:"WSClient [connect] 'clientOptions' has not been set.",type:"error"});if(void 0===o&&(o=this.clientOptions.connectTimeout),!Number.isInteger(o)||o<0)throw new TypeError("'timeout' must be a positive integer.");return void 0!==t(this,G)?e(this,P,new(t(this,D))(this.url,t(this,z).protocol,t(this,G))):e(this,P,new(t(this,D))(this.url,t(this,z).protocol)),t(this,P).binaryType=t(this,z).binaryType,t(this,P).onclose=()=>{e(this,J,!1),e(this,P,void 0),this.onSocketClose(),t(this,z).trigger&&super.triggerDefer("socket:close"),t(this,z).autoReconnect&&setTimeout(this.connect.bind(this),t(this,z).reconnectInterval)},t(this,P).onerror=e=>{this.onSocketError(e),t(this,z).trigger&&super.triggerDefer("socket:error",e)},t(this,P).onmessage=e=>{let n;try{n="string"==typeof e.data?t(this,z).serializer.parse(e.data):e.data}catch(t){n=e.data}this.onSocketMessage(n),t(this,z).trigger&&super.triggerDefer("socket:message:in",n)},t(this,P).onopen=()=>{e(this,J,!0),this.onSocketOpen(),t(this,z).trigger&&super.triggerDefer("socket:open"),t(this,q).process()},new Promise(((e,n)=>{const i=setTimeout((()=>{n({message:"WSClient [connect] timed out.",type:"error"})}),o),s=t=>{n(t)},r=()=>{clearTimeout(i),t(this,P)&&(t(this,P).removeEventListener("error",r),t(this,P).removeEventListener("error",s)),e()};t(this,P).addEventListener("open",r),t(this,P).addEventListener("error",s)}))}async disconnect({code:n,reason:i}={}){let o;return t(this,P)&&(o=new Promise(((e,n)=>{t(this,P).addEventListener("close",(()=>{e()})),t(this,P).addEventListener("error",(t=>{n(t)}))})),t(this,P).close(n,i)),e(this,J,!1),t(this,q).empty(),o}get bufferedAmount(){return t(this,P)?t(this,P).bufferedAmount:0}get clientOptions(){return t(this,z)}get connected(){return t(this,J)}get extensions(){return t(this,P)?t(this,P).extensions:""}get protocol(){return t(this,P)?t(this,P).protocol:""}get queue(){return t(this,q)}get readyState(){return t(this,P)?t(this,P).readyState:3}get url(){return t(this,P)?t(this,P).url:t(this,z)?t(this,z).url:""}get wsOptions(){return t(this,G)}onInitialize(){}onSocketClose(){}onSocketError(t){}onSocketMessage(t){}onSocketOpen(){}async reconnect({clientOptions:t,wsOptions:n,code:i=1e3,reason:o="reconnecting",timeout:s}={}){if(void 0!==t&&e(this,z,L(t)),void 0!==n&&"object"!=typeof n)throw new TypeError("'wsOptions' is not an object.");return void 0!==n&&e(this,G,n),await this.disconnect({code:i,reason:o}),this.connect({timeout:s})}send(e){return t(this,P)&&t(this,z)&&t(this,P).send(e.constructor===Object?t(this,z).serializer.stringify(e):e),this}sendAll(e){if(t(this,P)&&t(this,z))for(const n of e)t(this,P).send(n.constructor===Object?t(this,z).serializer.stringify(n):n);return this}setOptions({clientOptions:t,wsOptions:n}={}){if(void 0!==t&&e(this,z,L(t)),void 0!==n&&"object"!=typeof n)throw new TypeError("'wsOptions' is not an object.");void 0!==n&&e(this,G,n)}}export default class extends U{constructor(t){super(WebSocket,t)}async connect({clientOptions:t,wsOptions:e,timeout:n}={}){return super.connect({clientOptions:t,wsOptions:void 0,timeout:n})}async reconnect({clientOptions:t,wsOptions:e,code:n=1e3,reason:i="reconnecting",timeout:o}={}){return super.reconnect({clientOptions:t,wsOptions:void 0,code:n,reason:i,timeout:o})}setOptions({clientOptions:t,wsOptions:e}={}){super.setOptions({clientOptions:t,wsOptions:void 0})}}export{M as Queue};
//# sourceMappingURL=WSClient.js.map
