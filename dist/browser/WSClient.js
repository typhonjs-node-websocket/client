function t(t,e){return function(t,e){return e.get?e.get.call(t):e.value}(t,n(t,e,"get"))}function e(t,e,i){return function(t,e,n){if(e.set)e.set.call(t,n);else{if(!e.writable)throw new TypeError("attempted to set read only private field");e.value=n}}(t,n(t,e,"set"),i),i}function n(t,e,n){if(!e.has(t))throw new TypeError("attempted to "+n+" private field on non-instance");return e.get(t)}function i(t,e){return function(t,e){return e.get?e.get.call(t):e.value}(t,s(t,e,"get"))}function o(t,e,n){return function(t,e,n){if(e.set)e.set.call(t,n);else{if(!e.writable)throw new TypeError("attempted to set read only private field");e.value=n}}(t,s(t,e,"set"),n),n}function s(t,e,n){if(!e.has(t))throw new TypeError("attempted to "+n+" private field on non-instance");return e.get(t)}const r=/\s+/;function c(t,e,n,i,o){let s,a=0;if(n&&"object"==typeof n){void 0!==i&&"context"in o&&void 0===o.context&&(o.context=i);for(s=h(n);a<s.length;a++)e=c(t,e,s[a],n[s[a]],o)}else if(n&&r.test(n))for(s=n.split(r);a<s.length;a++)e=t(e,s[a],i,o);else e=t(e,n,i,o);return e}function a(t){const e=t.name;return""!==e?`[${e}] `:""}function l(t,e,n,i){const o=i.events;if(o){const n=o[e];if(Array.isArray(n))for(const e of n)e.options.guard&&(t.guard=!0),e.options.type>t.type&&(t.type=e.options.type)}return t}const h=t=>null===t||"object"!=typeof t?[]:Object.keys(t);function u(t,e,n,i){const o=i.after,s=i.count+1;if(n){const i=t[e]=p(s,(function(){return n.apply(this,arguments)}),(()=>{o(e,i)}));i._callback=n}return t}const p=function(t,e,n){let i;return function(...o){return--t>0&&(i=e.apply(this,o)),t<=1&&(n&&n.apply(this,o),n=void 0,e=void 0),i}};var f=new WeakMap,d=new WeakMap;class g{constructor(t=""){if(f.set(this,{writable:!0,value:""}),d.set(this,{writable:!0,value:void 0}),"string"!=typeof t)throw new TypeError("'name' is not a string");o(this,f,t),this._listeners=void 0,this._listenId=void 0,this._listeningTo=void 0}before(t,e,n,i,o={}){if(!Number.isInteger(t))throw new TypeError("'count' is not an integer");const s={};if(this.isGuarded(e,s))return console.warn(`@typhonjs-plugin/eventbus ${a(this)}- before() failed as event name(s) are guarded: ${JSON.stringify(s.names)}`),this;const r=c(u,{},e,n,{count:t,after:this.off.bind(this)});return"string"==typeof e&&null==i&&(n=void 0),this.on(r,n,i,o)}*entries(t){if(void 0!==t&&!(t instanceof RegExp))throw new TypeError("'regex' is not a RegExp");if(i(this,d))if(t){for(const e in i(this,d))if(t.test(e))for(const t of i(this,d)[e])yield[e,t.callback,t.context,JSON.parse(JSON.stringify(t.options))]}else for(const t in i(this,d))for(const e of i(this,d)[t])yield[t,e.callback,e.context,JSON.parse(JSON.stringify(e.options))]}get eventCount(){return i(this,d)?Object.keys(i(this,d)).length:0}get callbackCount(){if(!i(this,d))return 0;let t=0;for(const e in i(this,d))t+=i(this,d)[e].length;return t}getOptions(t){const e=c(l,{guard:!1,type:0},t,void 0,{events:i(this,d)});let n;switch(e.type){case 1:n="sync";break;case 2:n="async"}return{guard:e.guard,type:n}}getType(t){switch(c(E,{type:0},t,void 0,{events:i(this,d)}).type){case 1:return"sync";case 2:return"async";default:return}}isGuarded(t,e={}){return e.names=[],e.guarded=!1,c(x,e,t,void 0,{events:i(this,d)}).guarded}*keys(t){if(void 0!==t&&!(t instanceof RegExp))throw new TypeError("'regex' is not a RegExp");if(i(this,d))if(t)for(const e in i(this,d))t.test(e)&&(yield e);else for(const t in i(this,d))yield t}*keysWithOptions(t){if(void 0!==t&&!(t instanceof RegExp))throw new TypeError("'regex' is not a RegExp");if(i(this,d))if(t)for(const e in i(this,d))t.test(e)&&(yield[e,this.getOptions(e)]);else for(const t in i(this,d))yield[t,this.getOptions(t)]}get name(){return i(this,f)}listenTo(t,e,n){if(!t)return this;const i={};if(R(t,e,i))return console.warn(`@typhonjs-plugin/eventbus ${a(this)}- listenTo() failed as event name(s) are guarded for target object: ${JSON.stringify(i.names)}`),this;const o=t._listenId||(t._listenId=$("l")),s=this._listeningTo||(this._listeningTo={});let r=y=s[o];r||(this._listenId||(this._listenId=$("l")),r=y=s[o]=new k(this,t));const c=_(t,e,n,this);if(y=void 0,c)throw c;return r.interop&&r.on(e,n),this}listenToBefore(t,e,n,i){if(!Number.isInteger(t))throw new TypeError("'count' is not an integer");const o=c(u,{},n,i,{count:t,after:this.stopListening.bind(this,e)});return this.listenTo(e,o)}listenToOnce(t,e,n){const i=c(u,{},e,n,{count:1,after:this.stopListening.bind(this,t)});return this.listenTo(t,i)}off(t,e,n){return i(this,d)?(o(this,d,c(S,i(this,d),t,e,{context:n,listeners:this._listeners})),this):this}on(t,e,n,s={}){if(null==s||s.constructor!==Object)throw new TypeError("'options' must be an object literal.");const r={};return this.isGuarded(t,r)?(console.warn(`@typhonjs-plugin/eventbus ${a(this)}- on() failed as event name(s) are guarded: ${JSON.stringify(r.names)}`),this):(o(this,d,c(j,i(this,d)||{},t,e,{context:n,ctx:this,options:s,listening:y})),y&&((this._listeners||(this._listeners={}))[y.id]=y,y.interop=!1),this)}once(t,e,n,i={}){const o={};if(this.isGuarded(t,o))return console.warn(`@typhonjs-plugin/eventbus ${a(this)}- once() failed as event name(s) are guarded: ${JSON.stringify(o.names)}`),this;const s=c(u,{},t,e,{count:1,after:this.off.bind(this)});return"string"==typeof t&&null==n&&(e=void 0),this.on(s,e,n,i)}stopListening(t,e,n){const i=this._listeningTo;if(!i)return this;const o=t?[t._listenId]:h(i);for(let t=0;t<o.length;t++){const s=i[o[t]];if(!s)break;s.obj.off(e,n,this),s.interop&&s.off(e,n)}return this}trigger(t,...e){return i(this,d)?(I(W,C,i(this,d),t,void 0,e),this):this}async triggerAsync(t,...e){if(!i(this,d))return;const n=I(W,A,i(this,d),t,void 0,e);return void 0!==n?Array.isArray(n)?Promise.all(n).then((t=>{let e=[];for(const n of t)Array.isArray(n)?e=e.concat(n):void 0!==n&&e.push(n);return e.length>1?e:1===e.length?e[0]:void 0})):n:void 0}triggerDefer(t,...e){return setTimeout((()=>{this.trigger(t,...e)}),0),this}triggerSync(t,...e){if(i(this,d))return I(W,N,i(this,d),t,void 0,e)}}let y;var b=new WeakMap,v=new WeakMap,w=new WeakMap,m=new WeakMap,T=new WeakMap,O=new WeakMap;class k{constructor(t,e){b.set(this,{writable:!0,value:void 0}),v.set(this,{writable:!0,value:void 0}),w.set(this,{writable:!0,value:void 0}),m.set(this,{writable:!0,value:void 0}),T.set(this,{writable:!0,value:void 0}),O.set(this,{writable:!0,value:0}),o(this,v,t._listenId),o(this,w,t),o(this,m,e),o(this,T,!0)}cleanup(){delete i(this,w)._listeningTo[i(this,m)._listenId],i(this,T)||delete i(this,m)._listeners[i(this,v)]}get id(){return i(this,v)}get interop(){return i(this,T)}get obj(){return i(this,m)}incrementCount(){o(this,O,+i(this,O)+1)}on(t,e,n){return o(this,b,c(j,i(this,b)||{},t,e,{context:n,ctx:this,options:{},listening:this})),this}off(t,e){let n;i(this,T)?(o(this,b,c(S,i(this,b),t,e,{context:void 0,listeners:void 0})),n=!i(this,b)):(o(this,O,+i(this,O)-1),n=0===i(this,O)),n&&this.cleanup()}set interop(t){if("boolean"!=typeof t)throw new TypeError("'value' is not a boolean");o(this,T,t)}}const E=(t,e,n,i)=>{const o=i.events;if(o){const n=o[e];if(Array.isArray(n))for(const e of n)e.options.type>t.type&&(t.type=e.options.type)}return t},x=(t,e,n,i)=>{const o=i.events;if(o){const n=o[e];if(Array.isArray(n))for(const i of n)if(i.options.guard)return t.names.push(e),t.guarded=!0,t}return t},S=(t,e,n,i)=>{if(!t)return;const o=i.context,s=i.listeners;let r,c=0;if(e||o||n){for(r=e?[e]:h(t);c<r.length;c++){const i=t[e=r[c]];if(!i)break;const s=[];for(let t=0;t<i.length;t++){const r=i[t];if(n&&n!==r.callback&&n!==r.callback._callback||o&&o!==r.context)s.push(r);else{const t=r.listening;t&&t.off(e,n)}}s.length?t[e]=s:delete t[e]}return t}for(r=h(s);c<r.length;c++)s[r[c]].cleanup()},j=(t,e,n,i)=>{if(n){const o=t[e]||(t[e]=[]),s=i.context,r=i.ctx,c=i.listening,a=JSON.parse(JSON.stringify(i.options));switch(a.guard="boolean"==typeof a.guard&&a.guard,a.type){case"sync":a.type=1;break;case"async":a.type=2;break;default:a.type=0}c&&c.incrementCount(),o.push({callback:n,context:s,ctx:s||r,options:a,listening:c})}return t},I=(t,e,n,i,o,s)=>{let c,a,l=0;if(i&&r.test(i))for(a=i.split(r);l<a.length;l++){const i=t(e,n,a[l],o,s),r=Array.isArray(c)?2:void 0!==c?1:0;if(Array.isArray(i))switch(r){case 0:c=i;break;case 1:c=[c].concat(i);break;case 2:c=c.concat(i)}else if(void 0!==i)switch(r){case 0:c=i;break;case 1:{const t=[c];t.push(i),c=t;break}case 2:c.push(i)}}else c=t(e,n,i,o,s);return c},W=(t,e,n,i,o)=>{let s;if(e){const i=e[n];let r=e.all;i&&r&&(r=r.slice()),i&&(s=t(i,o)),r&&(s=t(r,[n].concat(o)))}return s},C=(t,e)=>{let n,i=-1;const o=e[0],s=e[1],r=e[2],c=t.length;switch(e.length){case 0:for(;++i<c;)(n=t[i]).callback.call(n.ctx);return;case 1:for(;++i<c;)(n=t[i]).callback.call(n.ctx,o);return;case 2:for(;++i<c;)(n=t[i]).callback.call(n.ctx,o,s);return;case 3:for(;++i<c;)(n=t[i]).callback.call(n.ctx,o,s,r);return;default:for(;++i<c;)(n=t[i]).callback.apply(n.ctx,e);return}},A=async(t,e)=>{let n,i=-1;const o=e[0],s=e[1],r=e[2],c=t.length,a=[];switch(e.length){case 0:for(;++i<c;){const e=(n=t[i]).callback.call(n.ctx);void 0!==e&&a.push(e)}break;case 1:for(;++i<c;){const e=(n=t[i]).callback.call(n.ctx,o);void 0!==e&&a.push(e)}break;case 2:for(;++i<c;){const e=(n=t[i]).callback.call(n.ctx,o,s);void 0!==e&&a.push(e)}break;case 3:for(;++i<c;){const e=(n=t[i]).callback.call(n.ctx,o,s,r);void 0!==e&&a.push(e)}break;default:for(;++i<c;){const o=(n=t[i]).callback.apply(n.ctx,e);void 0!==o&&a.push(o)}}return a.length>1?Promise.all(a).then((t=>{const e=t.filter((t=>void 0!==t));switch(e.length){case 0:return;case 1:return e[0];default:return e}})):1===a.length?a[0]:void 0},N=(t,e)=>{let n,i=-1;const o=e[0],s=e[1],r=e[2],c=t.length,a=[];switch(e.length){case 0:for(;++i<c;){const e=(n=t[i]).callback.call(n.ctx);void 0!==e&&a.push(e)}break;case 1:for(;++i<c;){const e=(n=t[i]).callback.call(n.ctx,o);void 0!==e&&a.push(e)}break;case 2:for(;++i<c;){const e=(n=t[i]).callback.call(n.ctx,o,s);void 0!==e&&a.push(e)}break;case 3:for(;++i<c;){const e=(n=t[i]).callback.call(n.ctx,o,s,r);void 0!==e&&a.push(e)}break;default:for(;++i<c;){const o=(n=t[i]).callback.apply(n.ctx,e);void 0!==o&&a.push(o)}}return a.length>1?a:1===a.length?a[0]:void 0},R=(t,e,n={})=>{let i=!1;try{const o=t.isGuarded(e,n);"boolean"==typeof o&&(i=o)}catch(t){i=!1,n.names=[],n.guarded=!1}return i},_=(t,e,n,i)=>{try{t.on(e,n,i)}catch(t){return t}};let M=0;const $=(t="")=>{const e=""+ ++M;return t?`${t}${e}`:e};new g("mainEventbus"),new g("pluginEventbus"),new g("testEventbus");class L{constructor(t){this.consumer=t,this.queue=[]}push(t){return this.queue.push(t),this.process()}pushAll(t){return this.queue.push(...t),this.process()}process(){return setTimeout((()=>{0!==this.queue.length&&this.consumer(this.queue[0])&&(this.queue.shift(),this.process())}),0),this}empty(){return this.queue=[],this}}const z=JSON;function J(t){if(null==t)throw new TypeError("'clientOptions' is null or undefined.");if("object"!=typeof t)throw new TypeError("'clientOptions' is not an object.");if(void 0!==t.url&&"string"!=typeof t.url&&!(t.url instanceof URL))throw new TypeError("'clientOptions.url' is not a string or URL.");let e="string"==typeof t.url?new URL(t.url.toLowerCase()):t.url;if(void 0!==e&&!e.protocol.match(/^wss?/))throw new TypeError("'clientOptions.url' is not a WebSocket URL.");if(void 0===e&&!Number.isInteger(t.port)||t.port<0||t.port>65535)throw new TypeError("'clientOptions.port' is not an integer between [0-65535].");if(void 0!==t.host&&"string"!=typeof t.host)throw new TypeError("'clientOptions.host' is not a string.");if(t.host=t.host||"localhost",void 0!==t.ssl&&"boolean"!=typeof t.ssl)throw new TypeError("'clientOptions.ssl' is not a boolean.");if(t.ssl="boolean"==typeof t.ssl&&t.ssl,void 0!==t.path&&"string"!=typeof t.path)throw new TypeError("'clientOptions.path' is not a string.");if(t.path="string"==typeof t.path?t.path:"/",t.path.startsWith("/")||(t.path=`/${t.path}`),void 0!==t.binaryType&&"string"!=typeof t.binaryType)throw new TypeError("'clientOptions.binaryType' must be 'blob' or 'arraybuffer'.");if(void 0!==t.binaryType&&"blob"!==t.binaryType&&"arraybuffer"!==t.binaryType)throw new TypeError("'clientOptions.binaryType' must be 'blob' or 'arraybuffer'.");if(t.binaryType="string"==typeof t.binaryType?t.binaryType:"blob",t.serializer=t.serializer||z,"object"!=typeof t.serializer||"function"!=typeof t.serializer.stringify||"function"!=typeof t.serializer.parse)throw new TypeError("'clientOptions.serializer' does not conform to the JSON API.");if(void 0!==t.autoConnect&&"boolean"!=typeof t.autoConnect)throw new TypeError("'clientOptions.autoConnect' is not a boolean.");if(void 0!==t.autoReconnect&&"boolean"!=typeof t.autoReconnect)throw new TypeError("'clientOptions.autoReconnect' is not a boolean.");if(void 0!==t.connectTimeout&&(!Number.isInteger(t.connectTimeout)||t.connectTimeout<0))throw new TypeError("'clientOptions.connectTimeout' is not an integer or < 0.");if(void 0!==t.messageTimeout&&(!Number.isInteger(t.messageTimeout)||t.messageTimeout<0))throw new TypeError("'clientOptions.messageTimeout' is not an integer or < 0.");if(void 0!==t.reconnectInterval&&(!Number.isInteger(t.reconnectInterval)||t.reconnectInterval<0))throw new TypeError("'clientOptions.reconnectInterval' is not an integer or < 0.");if(t.autoConnect="boolean"==typeof t.autoConnect&&t.autoConnect,t.autoReconnect="boolean"==typeof t.autoReconnect&&t.autoReconnect,t.connectTimeout=t.connectTimeout||5e3,t.messageTimeout=t.messageTimeout||1e4,t.reconnectInterval=t.reconnectInterval||2e3,void 0!==t.trigger&&"boolean"!=typeof t.trigger)throw new TypeError("'clientOptions.trigger' is not a boolean.");if(t.trigger="boolean"!=typeof t.trigger||t.trigger,void 0!==t.protocol&&"string"!=typeof t.protocol&&!Array.isArray(t.protocol))throw new TypeError("'clientOptions.protocol' is not a string or string[].");return t.protocol=t.protocol?t.protocol:[],void 0===e?e=new URL(`${t.ssl?"wss://":"ws://"}${t.host}:${t.port}${t.path}`):(t.host=e.hostname,t.port=Number.parseInt(e.port),t.path=e.pathname,t.ssl=e.protocol.startsWith("wss")),{url:e.toString(),host:t.host,port:t.port,ssl:t.ssl,path:t.path,binaryType:t.binaryType,serializer:t.serializer,autoConnect:t.autoConnect,autoReconnect:t.autoReconnect,connectTimeout:t.connectTimeout,messageTimeout:t.messageTimeout,reconnectInterval:t.reconnectInterval,protocol:t.protocol,trigger:t.trigger}}var q=new WeakMap,P=new WeakMap,D=new WeakMap,G=new WeakMap,U=new WeakMap,B=new WeakMap;class F extends g{constructor(n,i,o){if(super(),q.set(this,{writable:!0,value:void 0}),P.set(this,{writable:!0,value:!1}),D.set(this,{writable:!0,value:void 0}),G.set(this,{writable:!0,value:void 0}),U.set(this,{writable:!0,value:void 0}),B.set(this,{writable:!0,value:void 0}),e(this,U,n),void 0!==i&&(e(this,q,J(i)),this.onSetClientOptions(t(this,q))),void 0!==o&&"object"!=typeof o)throw new TypeError("'wsOptions' is not an object.");void 0!==o&&(e(this,B,o),this.onSetWSOptions(t(this,B))),e(this,D,new L((e=>!!t(this,P)&&(this.send(e),!0)))),t(this,q)&&t(this,q).autoConnect&&setTimeout(this.connect.bind(this),0),this.onInitialize()}async connect({clientOptions:n,wsOptions:i,timeout:o}={}){if(t(this,G))return Promise.reject({message:"WSClient [connect] already created WebSocket.",type:"error"});if(void 0!==n&&(e(this,q,J(n)),this.onSetClientOptions(t(this,q))),void 0!==i&&"object"!=typeof i)throw new TypeError("'wsOptions' is not an object.");if(void 0!==i&&(e(this,B,i),this.onSetWSOptions(t(this,B))),"object"!=typeof t(this,q))return Promise.reject({message:"WSClient [connect] 'clientOptions' has not been set.",type:"error"});if(void 0===o&&(o=this.clientOptions.connectTimeout),!Number.isInteger(o)||o<0)throw new TypeError("'timeout' must be a positive integer.");return void 0!==t(this,B)?e(this,G,new(t(this,U))(this.url,t(this,q).protocol,t(this,B))):e(this,G,new(t(this,U))(this.url,t(this,q).protocol)),t(this,G).binaryType=t(this,q).binaryType,t(this,G).onclose=()=>{e(this,P,!1),e(this,G,void 0),this.onSocketClose(),t(this,q).trigger&&super.triggerDefer("socket:close"),t(this,q).autoReconnect&&setTimeout(this.connect.bind(this),t(this,q).reconnectInterval)},t(this,G).onerror=e=>{this.onSocketError(e),t(this,q).trigger&&super.triggerDefer("socket:error",e)},t(this,G).onmessage=e=>{let n;try{n="string"==typeof e.data?t(this,q).serializer.parse(e.data):e.data}catch(t){n=e.data}this.onSocketMessage(n),t(this,q).trigger&&super.triggerDefer("socket:message:in",n)},t(this,G).onopen=()=>{e(this,P,!0),this.onSocketOpen(),t(this,q).trigger&&super.triggerDefer("socket:open"),t(this,D).process()},new Promise(((e,n)=>{const i=setTimeout((()=>{n({message:"WSClient [connect] timed out.",type:"error"})}),o),s=t=>{n(t)},r=()=>{clearTimeout(i),t(this,G)&&(t(this,G).removeEventListener("error",r),t(this,G).removeEventListener("error",s)),e()};t(this,G).addEventListener("open",r),t(this,G).addEventListener("error",s)}))}async disconnect({code:n,reason:i}={}){let o;return t(this,G)&&(o=new Promise(((e,n)=>{t(this,G).addEventListener("close",(()=>{e()})),t(this,G).addEventListener("error",(t=>{n(t)}))})),t(this,G).close(n,i)),e(this,P,!1),t(this,D).empty(),o}get bufferedAmount(){return t(this,G)?t(this,G).bufferedAmount:0}get clientOptions(){return t(this,q)}get connected(){return t(this,P)}get extensions(){return t(this,G)?t(this,G).extensions:""}get protocol(){return t(this,G)?t(this,G).protocol:""}get queue(){return t(this,D)}get readyState(){return t(this,G)?t(this,G).readyState:3}get url(){return t(this,G)?t(this,G).url:t(this,q)?t(this,q).url:""}get wsOptions(){return t(this,B)}onInitialize(){}onSetClientOptions(t){}onSetWSOptions(t){}onSocketClose(){}onSocketError(t){}onSocketMessage(t){}onSocketOpen(){}async reconnect({clientOptions:n,wsOptions:i,code:o=1e3,reason:s="reconnecting",timeout:r}={}){if(void 0!==n&&(e(this,q,J(n)),this.onSetClientOptions(t(this,q))),void 0!==i&&"object"!=typeof i)throw new TypeError("'wsOptions' is not an object.");return void 0!==i&&(e(this,B,i),this.onSetWSOptions(t(this,B))),await this.disconnect({code:o,reason:s}),this.connect({timeout:r})}send(e){return t(this,G)&&t(this,q)&&t(this,G).send(e.constructor===Object?t(this,q).serializer.stringify(e):e),this}sendAll(e){if(t(this,G)&&t(this,q))for(const n of e)t(this,G).send(n.constructor===Object?t(this,q).serializer.stringify(n):n);return this}setOptions({clientOptions:n,wsOptions:i}={}){if(void 0!==n&&(e(this,q,J(n)),this.onSetClientOptions(t(this,q))),void 0!==i&&"object"!=typeof i)throw new TypeError("'wsOptions' is not an object.");void 0!==i&&(e(this,B,i),this.onSetWSOptions(t(this,B)))}}export default class extends F{constructor(t,e){super(WebSocket,t)}async connect({clientOptions:t,wsOptions:e,timeout:n}={}){return super.connect({clientOptions:t,wsOptions:void 0,timeout:n})}async reconnect({clientOptions:t,wsOptions:e,code:n=1e3,reason:i="reconnecting",timeout:o}={}){return super.reconnect({clientOptions:t,wsOptions:void 0,code:n,reason:i,timeout:o})}setOptions({clientOptions:t,wsOptions:e}={}){super.setOptions({clientOptions:t,wsOptions:void 0})}}export{L as Queue};
//# sourceMappingURL=WSClient.js.map
