{"version":3,"file":"WebSocket.js","sources":["../../node_modules/@typhonjs-plugin/eventbus/src/utils.js","../../node_modules/@typhonjs-plugin/eventbus/src/Eventbus.js","../../node_modules/@typhonjs-plugin/eventbus/src/index.js","../../src/utils/Queue.js","../../src/utils/setClientOptions.js","../../src/AbstractWSClient.js","../../src/browser/WSClient.js","../../src/browser/WSServer.js"],"sourcesContent":["/**\n * Regular expression used to split event strings.\n *\n * @type {RegExp}\n */\nexport const eventSplitter = /\\s+/;\n\n/**\n * Iterates over the standard `event, callback` (as well as the fancy multiple space-separated events `\"change blur\",\n * callback` and jQuery-style event maps `{event: callback}`).\n *\n * @template T\n *\n * @param {Function}       iteratee - Event operation to invoke.\n *\n * @param {T}              events - Events object\n *\n * @param {string|object}  name - A single event name, compound event names, or a hash of event names.\n *\n * @param {Function}       callback - Event callback function\n *\n * @param {object}         opts - Optional parameters\n *\n * @returns {T} Events object or processed data.\n */\nexport function eventsAPI(iteratee, events, name, callback, opts)\n{\n   let i = 0, names;\n   if (name && typeof name === 'object')\n   {\n      // Handle event maps.\n      if (callback !== void 0 && 'context' in opts && opts.context === void 0) { opts.context = callback; }\n      for (names = objectKeys(name); i < names.length; i++)\n      {\n         events = eventsAPI(iteratee, events, names[i], name[names[i]], opts);\n      }\n   }\n   else if (name && eventSplitter.test(name))\n   {\n      // Handle space-separated event names by delegating them individually.\n      for (names = name.split(eventSplitter); i < names.length; i++)\n      {\n         events = iteratee(events, names[i], callback, opts);\n      }\n   }\n   else\n   {\n      // Finally, standard events.\n      events = iteratee(events, name, callback, opts);\n   }\n   return events;\n}\n\n/**\n * Returns a string to output for error messages including any eventbus name.\n *\n * @param {Eventbus|EventbusProxy|EventbusSecure} eventbus - The eventbus to format.\n *\n * @returns {string} A string representing the eventbus.\n */\nexport function getErrorName(eventbus)\n{\n   const name = eventbus.name;\n   return name !== '' ? `[${name}] ` : '';\n}\n\n/**\n * The reducing API that returns the options for an event. Any guarded event sets guard and the higher type is set.\n *\n * @param {object}   output - The output object.\n *\n * @param {string}   name - Event name\n *\n * @param {Function} callback - Event callback\n *\n * @param {object}   opts - Optional parameters\n *\n * @returns {object} The output object.\n */\nexport function getOptions(output, name, callback, opts)\n{\n   const events = opts.events;\n\n   if (events)\n   {\n      const handlers = events[name];\n\n      if (Array.isArray(handlers))\n      {\n         for (const handler of handlers)\n         {\n            if (handler.options.guard)\n            {\n               output.guard = true;\n            }\n\n            if (handler.options.type > output.type)\n            {\n               output.type = handler.options.type;\n            }\n         }\n      }\n   }\n\n   return output;\n}\n\n/**\n * Provides  protected Object.keys functionality.\n *\n * @param {object}   object - Object to retrieve keys.\n *\n * @returns {string[]} Keys of object if any.\n */\nexport const objectKeys = (object) =>\n{\n   return object === null || typeof object !== 'object' ? [] : Object.keys(object);\n};\n\n/**\n * Reduces the event callbacks into a map of `{event: beforeWrapper}`. `after` unbinds the `beforeWrapper` after\n * it has been called the number of times specified by options.count.\n *\n * @param {Events}   map - Events object\n *\n * @param {string}   name - Event name\n *\n * @param {Function} callback - Event callback\n *\n * @param {object}   opts - Function to invoke after event has been triggered once; `off()`\n *\n * @returns {Events} The Events object.\n */\nexport function beforeMap(map, name, callback, opts)\n{\n   const after = opts.after;\n   const count = opts.count + 1;\n\n   if (callback)\n   {\n      const beforeWrapper = map[name] = s_BEFORE(count, function()\n      {\n         return callback.apply(this, arguments);\n      }, () => { after(name, beforeWrapper); });\n\n      beforeWrapper._callback = callback;\n   }\n   return map;\n}\n\n// Module Private ----------------------------------------------------------------------------------------------------\n\n/**\n * Creates a function that invokes `before`, with the `this` binding and arguments of the created function, while\n * it's called less than `count` times. Subsequent calls to the created function return the result of the last `before`\n * invocation.\n *\n * `after` is invoked after the count is reduced.\n *\n * @param {number}   count - The number of calls at which `before` is no longer invoked and then `after` is invoked.\n *\n * @param {Function} before - The function to restrict.\n *\n * @param {Function} after - The function to invoke after count number of calls.\n *\n * @returns {Function} Returns the new restricted function.\n */\nconst s_BEFORE = function(count, before, after)\n{\n   let result;\n\n   return function(...args)\n   {\n      if (--count > 0) { result = before.apply(this, args); }\n\n      if (count <= 1)\n      {\n         if (after) { after.apply(this, args); }\n         after = void 0;\n         before = void 0;\n      }\n\n      return result;\n   };\n};\n","import * as Utils from './utils.js';\n\n/**\n * `@typhonjs-plugin/eventbus` / Provides the ability to bind and trigger custom named events.\n *\n * This module is an evolution of Backbone Events. (http://backbonejs.org/#Events). Eventbus extends the\n * functionality provided in Backbone Events with additional triggering methods to receive asynchronous and\n * synchronous results.\n *\n * ---------------\n */\nexport default class Eventbus\n{\n   /**\n    * Stores the name of this eventbus.\n    *\n    * @type {string}\n    * @private\n    */\n   #name = '';\n\n   /**\n    * Stores the events map for associated events and callback / context data.\n    *\n    * @type {Events|{}}\n    * @private\n    */\n   #events;\n\n   /**\n    * Provides a constructor which optionally takes the eventbus name.\n    *\n    * @param {string}   name - Optional eventbus name.\n    */\n   constructor(name = '')\n   {\n      if (typeof name !== 'string') { throw new TypeError(`'name' is not a string`); }\n\n      this.#name = name;\n\n      /**\n       * Stores the Listening instances for this context.\n       *\n       * @type {object.<string, Listening>}\n       * @private\n       */\n      this._listeners = void 0;\n\n      /**\n       * A unique ID set when listened to.\n       *\n       * @type {string}\n       * @private\n       */\n      this._listenId = void 0;\n\n      /**\n       * Stores the Listening instances for other contexts.\n       *\n       * @type {object.<string, Listening>}\n       * @private\n       */\n      this._listeningTo = void 0;\n   }\n\n   /**\n    * Just like `on`, but causes the bound callback to fire several times up to the count specified before being\n    * removed. When multiple events are passed in using the space separated syntax, the event\n    * will fire count times for every event you passed in, not once for a combination of all events.\n    *\n    * @param {number}            count - Number of times the function will fire before being removed.\n    *\n    * @param {string|object}     name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @param {object}            [context] - Event context\n    *\n    * @param {OnOptions}         [options] - Event registration options.\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   before(count, name, callback, context = void 0, options = {})\n   {\n      if (!Number.isInteger(count)) { throw new TypeError(`'count' is not an integer`); }\n\n      const data = {};\n      if (this.isGuarded(name, data))\n      {\n         console.warn(`@typhonjs-plugin/eventbus ${Utils.getErrorName(this)}`\n          + `- before() failed as event name(s) are guarded: ${JSON.stringify(data.names)}`);\n         return this;\n      }\n\n      // Map the event into a `{event: beforeWrapper}` object.\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, { count, after: this.off.bind(this) });\n\n      if (typeof name === 'string' && (context === null || context === void 0)) { callback = void 0; }\n\n      return this.on(events, callback, context, options);\n   }\n\n   /**\n    * Returns an iterable for all stored events yielding an array with event name, callback function, and event context.\n    *\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\n    *\n    * @yields\n    */\n   *entries(regex = void 0)\n   {\n      if (regex !== void 0 && !(regex instanceof RegExp)) { throw new TypeError(`'regex' is not a RegExp`); }\n\n      if (!this.#events) { return; }\n\n      if (regex)\n      {\n         for (const name in this.#events)\n         {\n            if (regex.test(name))\n            {\n               for (const event of this.#events[name])\n               {\n                  yield [name, event.callback, event.context, JSON.parse(JSON.stringify(event.options))];\n               }\n            }\n         }\n      }\n      else\n      {\n         for (const name in this.#events)\n         {\n            for (const event of this.#events[name])\n            {\n               yield [name, event.callback, event.context, JSON.parse(JSON.stringify(event.options))];\n            }\n         }\n      }\n   }\n\n   /**\n    * Returns the current event count.\n    *\n    * @returns {number} Returns the current event count.\n    */\n   get eventCount()\n   {\n      if (!this.#events) { return 0; }\n\n      return Object.keys(this.#events).length;\n   }\n\n   /**\n    * Returns the current callback count.\n    *\n    * @returns {number} The current callback count.\n    */\n   get callbackCount()\n   {\n      if (!this.#events) { return 0; }\n\n      let count = 0;\n\n      for (const name in this.#events) { count += this.#events[name].length; }\n\n      return count;\n   }\n\n   /**\n    * Returns the options of an event name.\n    *\n    * @param {string}   name - Event name(s) to verify.\n    *\n    * @returns {DataOutOptions} The event options.\n    */\n   getOptions(name)\n   {\n      const result = Utils.eventsAPI(Utils.getOptions, { guard: false, type: 0 }, name, void 0,\n       { events: this.#events });\n\n      let type = void 0;\n\n      switch(result.type)\n      {\n         case 1:\n            type = 'sync';\n            break;\n         case 2:\n            type = 'async';\n            break;\n      }\n\n      return { guard: result.guard, type };\n   }\n\n   /**\n    * Returns the trigger type of an event name.\n    * Note: if trigger type is not set then undefined is returned for type otherwise 'sync' or 'async' is returned.\n    *\n    * @param {string}   name - Event name(s) to verify.\n    *\n    * @returns {string|undefined} The trigger type.\n    */\n   getType(name)\n   {\n      const result = Utils.eventsAPI(s_GET_TYPE, { type: 0 }, name, void 0, { events: this.#events });\n\n      switch(result.type)\n      {\n         case 1:\n            return 'sync';\n         case 2:\n            return 'async';\n         default:\n            return void 0;\n      }\n   }\n\n   /**\n    * Returns whether an event name is guarded.\n    *\n    * @param {string|object}  name - Event name(s) or event map to verify.\n    *\n    * @param {object}         [data] - Stores the output of which names are guarded.\n    *\n    * @returns {boolean} Whether the given event name is guarded.\n    */\n   isGuarded(name, data = {})\n   {\n      data.names = [];\n      data.guarded = false;\n\n      const result = Utils.eventsAPI(s_IS_GUARDED, data, name, void 0, { events: this.#events });\n\n      return result.guarded;\n   }\n\n   /**\n    * Returns an iterable for the event names / keys of registered event listeners.\n    *\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\n    *\n    * @yields\n    */\n   *keys(regex = void 0)\n   {\n      if (regex !== void 0 && !(regex instanceof RegExp)) { throw new TypeError(`'regex' is not a RegExp`); }\n\n      if (!this.#events) { return; }\n\n      if (regex)\n      {\n         for (const name in this.#events)\n         {\n            if (regex.test(name))\n            {\n               yield name;\n            }\n         }\n      }\n      else\n      {\n         for (const name in this.#events)\n         {\n            yield name;\n         }\n      }\n   }\n\n   /**\n    * Returns an iterable for the event names / keys of registered event listeners along with event options.\n    *\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\n    *\n    * @yields\n    */\n   *keysWithOptions(regex = void 0)\n   {\n      if (regex !== void 0 && !(regex instanceof RegExp)) { throw new TypeError(`'regex' is not a RegExp`); }\n\n      if (!this.#events) { return; }\n\n      if (regex)\n      {\n         for (const name in this.#events)\n         {\n            if (regex.test(name))\n            {\n               yield [name, this.getOptions(name)];\n            }\n         }\n      }\n      else\n      {\n         for (const name in this.#events)\n         {\n            yield [name, this.getOptions(name)];\n         }\n      }\n   }\n\n   /**\n    * Returns the current eventbus name.\n    *\n    * @returns {string} The current eventbus name.\n    */\n   get name()\n   {\n      return this.#name;\n   }\n\n   /**\n    * Tell an object to listen to a particular event on an other object. The advantage of using this form, instead of\n    * other.on(event, callback, object), is that listenTo allows the object to keep track of the events, and they can\n    * be removed all at once later on. The callback will always be called with object as context.\n    *\n    * @example\n    * view.listenTo(model, 'change', view.render);\n    *\n    * @param {object}            obj - Event context\n    *\n    * @param {string|object}     name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   listenTo(obj, name, callback)\n   {\n      if (!obj) { return this; }\n\n      const data = {};\n      if (s_TRY_CATCH_IS_GUARDED(obj, name, data))\n      {\n         console.warn(`@typhonjs-plugin/eventbus ${Utils.getErrorName(this)}`\n          + `- listenTo() failed as event name(s) are guarded for target object: ${JSON.stringify(data.names)}`);\n         return this;\n      }\n\n      const id = obj._listenId || (obj._listenId = s_UNIQUE_ID('l'));\n      const listeningTo = this._listeningTo || (this._listeningTo = {});\n      let listening = _listening = listeningTo[id];\n\n      // This object is not listening to any other events on `obj` yet.\n      // Setup the necessary references to track the listening callbacks.\n      if (!listening)\n      {\n         this._listenId || (this._listenId = s_UNIQUE_ID('l'));\n         listening = _listening = listeningTo[id] = new Listening(this, obj);\n      }\n\n      // Bind callbacks on obj.\n      const error = s_TRY_CATCH_ON(obj, name, callback, this);\n      _listening = void 0;\n\n      if (error) { throw error; }\n\n      // If the target obj is not an Eventbus, track events manually.\n      if (listening.interop) { listening.on(name, callback); }\n\n      return this;\n   }\n\n   /**\n    * Just like `listenTo`, but causes the bound callback to fire count times before being removed.\n    *\n    * @param {number}            count - Number of times the function will fire before being removed.\n    *\n    * @param {object}            obj - Target event context.\n    *\n    * @param {string|object}     name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   listenToBefore(count, obj, name, callback)\n   {\n      if (!Number.isInteger(count)) { throw new TypeError(`'count' is not an integer`); }\n\n      // Map the event into a `{event: beforeWrapper}` object.\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, {\n         count,\n         after: this.stopListening.bind(this, obj)\n      });\n\n      return this.listenTo(obj, events);\n   }\n\n   /**\n    * Just like `listenTo`, but causes the bound callback to fire only once before being removed.\n    *\n    * @param {object}            obj - Target event context\n    *\n    * @param {string|object}     name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   listenToOnce(obj, name, callback)\n   {\n      // Map the event into a `{event: beforeWrapper}` object.\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, {\n         count: 1,\n         after: this.stopListening.bind(this, obj)\n      });\n\n      return this.listenTo(obj, events);\n   }\n\n   /**\n    * Remove a previously-bound callback function from an object. If no context is specified, all of the versions of\n    * the callback with different contexts will be removed. If no callback is specified, all callbacks for the event\n    * will be removed. If no event is specified, callbacks for all events will be removed.\n    *\n    * Note that calling model.off(), for example, will indeed remove all events on the model â€” including events that\n    * Backbone uses for internal bookkeeping.\n    *\n    * @example\n    * // Removes just the `onChange` callback.\n    * object.off(\"change\", onChange);\n    *\n    * // Removes all \"change\" callbacks.\n    * object.off(\"change\");\n    *\n    * // Removes the `onChange` callback for all events.\n    * object.off(null, onChange);\n    *\n    * // Removes all callbacks for `context` for all events.\n    * object.off(null, null, context);\n    *\n    * // Removes all callbacks on `object`.\n    * object.off();\n    *\n    * @param {string|object}  [name] - Event name(s) or event map.\n    *\n    * @param {Function}       [callback] - Event callback function\n    *\n    * @param {object}         [context] - Event context\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   off(name, callback = void 0, context = void 0)\n   {\n      if (!this.#events) { return this; }\n\n      this.#events = Utils.eventsAPI(s_OFF_API, this.#events, name, callback, { context, listeners: this._listeners });\n\n      return this;\n   }\n\n   /**\n    * Bind a callback function to an object. The callback will be invoked whenever the event is fired. If you have a\n    * large number of different events on a page, the convention is to use colons to namespace them: \"poll:start\", or\n    * \"change:selection\".\n    *\n    * To supply a context value for this when the callback is invoked, pass the optional last argument:\n    * model.on('change', this.render, this) or model.on({change: this.render}, this).\n    *\n    * @example\n    * The event string may also be a space-delimited list of several events...\n    * book.on(\"change:title change:author\", ...);\n    *\n    * @example\n    * Callbacks bound to the special \"all\" event will be triggered when any event occurs, and are passed the name of\n    * the event as the first argument. For example, to proxy all events from one object to another:\n    * proxy.on(\"all\", function(eventName) {\n    *    object.trigger(eventName);\n    * });\n    *\n    * @example\n    * All Backbone event methods also support an event map syntax, as an alternative to positional arguments:\n    * book.on({\n    *    \"change:author\": authorPane.update,\n    *    \"change:title change:subtitle\": titleView.update,\n    *    \"destroy\": bookView.remove\n    * });\n    *\n    * @param {string|object}     name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @param {object}            [context] - Event context\n    *\n    * @param {OnOptions}         [options] - Event registration options.\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   on(name, callback, context = void 0, options = {})\n   {\n      if (options == null || options.constructor !== Object)   // eslint-disable-line eqeqeq\n      {\n         throw new TypeError(`'options' must be an object literal.`);\n      }\n\n      const data = {};\n      if (this.isGuarded(name, data))\n      {\n         console.warn(`@typhonjs-plugin/eventbus ${Utils.getErrorName(this)}`\n          + `- on() failed as event name(s) are guarded: ${JSON.stringify(data.names)}`);\n         return this;\n      }\n\n      this.#events = Utils.eventsAPI(s_ON_API, this.#events || {}, name, callback, {\n         context,\n         ctx: this,\n         options,\n         listening: _listening\n      });\n\n      if (_listening)\n      {\n         const listeners = this._listeners || (this._listeners = {});\n         listeners[_listening.id] = _listening;\n\n         // Allow the listening to use a counter, instead of tracking callbacks for library interop.\n         _listening.interop = false;\n      }\n\n      return this;\n   }\n\n   /**\n    * Just like `on`, but causes the bound callback to fire only once before being removed. Handy for saying \"the next\n    * time that X happens, do this\". When multiple events are passed in using the space separated syntax, the event\n    * will fire once for every event you passed in, not once for a combination of all events\n    *\n    * @param {string|object}     name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @param {object}            [context] - Event context.\n    *\n    * @param {OnOptions}         [options] - Event registration options.\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   once(name, callback, context = void 0, options = {})\n   {\n      const data = {};\n      if (this.isGuarded(name, data))\n      {\n         console.warn(`@typhonjs-plugin/eventbus ${Utils.getErrorName(this)}`\n          + `- once() failed as event name(s) are guarded: ${JSON.stringify(data.names)}`);\n         return this;\n      }\n\n      // Map the event into a `{event: beforeWrapper}` object.\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, { count: 1, after: this.off.bind(this) });\n\n      if (typeof name === 'string' && (context === null || context === void 0)) { callback = void 0; }\n\n      return this.on(events, callback, context, options);\n   }\n\n   /**\n    * Tell an object to stop listening to events. Either call stopListening with no arguments to have the object remove\n    * all of its registered callbacks ... or be more precise by telling it to remove just the events it's listening to\n    * on a specific object, or a specific event, or just a specific callback.\n    *\n    * @example\n    * view.stopListening();\n    *\n    * view.stopListening(model);\n    *\n    * @param {object}   obj - Event context\n    *\n    * @param {string}   [name] - Event name(s)\n    *\n    * @param {Function} [callback] - Event callback function\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   stopListening(obj, name = void 0, callback = void 0)\n   {\n      const listeningTo = this._listeningTo;\n      if (!listeningTo) { return this; }\n\n      const ids = obj ? [obj._listenId] : Utils.objectKeys(listeningTo);\n\n      for (let i = 0; i < ids.length; i++)\n      {\n         const listening = listeningTo[ids[i]];\n\n         // If listening doesn't exist, this object is not currently listening to obj. Break out early.\n         if (!listening) { break; }\n\n         listening.obj.off(name, callback, this);\n\n         if (listening.interop) { listening.off(name, callback); }\n      }\n\n      return this;\n   }\n\n   /**\n    * Trigger callbacks for the given event, or space-delimited list of events. Subsequent arguments to trigger will be\n    * passed along to the event callbacks.\n    *\n    * @param {string}   name - Event name(s)\n    *\n    * @param {...*}     args - Additional arguments passed to the event function(s).\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   trigger(name, ...args)\n   {\n      if (!this.#events) { return this; }\n\n      s_RESULTS_TARGET_API(s_TRIGGER_API, s_TRIGGER_EVENTS, this.#events, name, void 0, args);\n\n      return this;\n   }\n\n   /**\n    * Provides `trigger` functionality, but collects any returned Promises from invoked targets and returns a\n    * single Promise generated by `Promise.resolve` for a single value or `Promise.all` for multiple results. This is\n    * a very useful mechanism to invoke asynchronous operations over an eventbus.\n    *\n    * @param {string}   name - Event name(s)\n    *\n    * @param {...*}     args - Additional arguments passed to the event function(s).\n    *\n    * @returns {Promise<void|*|*[]>} A Promise with any results.\n    */\n   async triggerAsync(name, ...args)\n   {\n      if (!this.#events) { return void 0; }\n\n      const result = s_RESULTS_TARGET_API(s_TRIGGER_API, s_TRIGGER_ASYNC_EVENTS, this.#events, name, void 0, args);\n\n      // No event callbacks were triggered.\n      if (result === void 0) { return void 0; }\n\n      // A single Promise has been returned; just return it.\n      if (!Array.isArray(result)) { return result; }\n\n      // Multiple events & callbacks have been triggered so reduce the returned array of Promises and filter all\n      // values from each Promise result removing any undefined values.\n      return Promise.all(result).then((results) =>\n      {\n         let allResults = [];\n\n         for (const pResult of results)\n         {\n            if (Array.isArray(pResult))\n            {\n               allResults = allResults.concat(pResult);\n            }\n            else if (pResult !== void 0)\n            {\n               allResults.push(pResult);\n            }\n         }\n\n         return allResults.length > 1 ? allResults : allResults.length === 1 ? allResults[0] : void 0;\n      });\n   }\n\n   /**\n    * Defers invoking `trigger`. This is useful for triggering events in the next clock tick.\n    *\n    * @param {string}   name - Event name(s)\n    *\n    * @param {...*}     args - Additional arguments passed to the event function(s).\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   triggerDefer(name, ...args)\n   {\n      setTimeout(() => { this.trigger(name, ...args); }, 0);\n\n      return this;\n   }\n\n   /**\n    * Provides `trigger` functionality, but collects any returned result or results from invoked targets as a single\n    * value or in an array and passes it back to the callee in a synchronous manner.\n    *\n    * @param {string}   name - Event name(s).\n    *\n    * @param {...*}     args - Additional arguments passed to the event function(s).\n    *\n    * @returns {void|*|*[]} The results of the event invocation.\n    */\n   triggerSync(name, ...args)\n   {\n      if (!this.#events) { return void 0; }\n\n      return s_RESULTS_TARGET_API(s_TRIGGER_API, s_TRIGGER_SYNC_EVENTS, this.#events, name, void 0, args);\n   }\n}\n\n// Private / internal methods ---------------------------------------------------------------------------------------\n\n/**\n * Global listening object\n *\n * @type {Listening}\n */\nlet _listening;\n\n/**\n * A listening class that tracks and cleans up memory bindings when all callbacks have been offed.\n */\nclass Listening\n{\n   /**\n    * @type {Events|{}}\n    */\n   #events;\n\n   /**\n    * @type {string}\n    */\n   #id;\n\n   /**\n    * @type {object}\n    */\n   #listener;\n\n   /**\n    * @type {object}\n    */\n   #obj;\n\n   /**\n    * @type {boolean}\n    */\n   #interop;\n\n   /**\n    * Current listening count.\n    *\n    * @type {number}\n    */\n   #count = 0;\n\n   constructor(listener, obj)\n   {\n      this.#id = listener._listenId;\n      this.#listener = listener;\n      this.#obj = obj;\n      this.#interop = true;\n   }\n\n   // Cleans up memory bindings between the listener and the listenee.\n   cleanup()\n   {\n      delete this.#listener._listeningTo[this.#obj._listenId];\n      if (!this.#interop) { delete this.#obj._listeners[this.#id]; }\n   }\n\n   get id() { return this.#id; }\n\n   get interop() { return this.#interop; }\n\n   get obj() { return this.#obj; }\n\n   incrementCount() { this.#count++; }\n\n   /**\n    * @see {@link Eventbus#on}\n    *\n    * @param {string|object}     name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @param {object}            [context] - Event context\n    *\n    * @returns {Listening} This Listening instance.\n    */\n   on(name, callback, context = void 0)\n   {\n      this.#events = Utils.eventsAPI(s_ON_API, this.#events || {}, name, callback,\n      {\n         context,\n         ctx: this,\n         options: {},\n         listening: this\n      });\n\n      return this;\n   }\n\n   /**\n    * Offs a callback (or several). Uses an optimized counter if the listenee uses Eventbus. Otherwise, falls back to\n    * manual tracking to support events library interop.\n    *\n    * @param {string|object}     [name] - Event name(s) or event map.\n    *\n    * @param {Function|object}   [callback] - Event callback function or context for event map.\n    */\n   off(name, callback)\n   {\n      let cleanup;\n\n      if (this.#interop)\n      {\n         this.#events = Utils.eventsAPI(s_OFF_API, this.#events, name, callback, {\n            context: void 0,\n            listeners: void 0\n         });\n         cleanup = !this.#events;\n      }\n      else\n      {\n         this.#count--;\n         cleanup = this.#count === 0;\n      }\n\n      if (cleanup) { this.cleanup(); }\n   }\n\n   /**\n    * Sets interop.\n    *\n    * @param {boolean} value Value to set.\n    */\n   set interop(value)\n   {\n      /* c8 ignore next 1 */\n      if (typeof value !== 'boolean') { throw new TypeError(`'value' is not a boolean`); }\n      this.#interop = value\n   }\n}\n\n/**\n * The reducing API that returns the trigger type for an event. The higher type is set.\n *\n * @param {object}   output - The output object.\n *\n * @param {string}   name - Event name\n *\n * @param {Function} callback - Event callback\n *\n * @param {object}   opts - Optional parameters\n *\n * @returns {object} The output object.\n */\nconst s_GET_TYPE = (output, name, callback, opts) =>\n{\n   const events = opts.events;\n\n   if (events)\n   {\n      const handlers = events[name];\n\n      if (Array.isArray(handlers))\n      {\n         for (const handler of handlers)\n         {\n            if (handler.options.type > output.type)\n            {\n               output.type = handler.options.type;\n            }\n         }\n      }\n   }\n\n   return output;\n}\n\n/**\n * The reducing API that tests if an event name is guarded. Any event data of a give event name can have the guarded\n * state set. If so the event name will be added to the output names array and `output.guarded` set to true.\n *\n * @param {object}   output - The output object.\n *\n * @param {string}   name - Event name\n *\n * @param {Function} callback - Event callback\n *\n * @param {object}   opts - Optional parameters\n *\n * @returns {object} The output object.\n */\nconst s_IS_GUARDED = (output, name, callback, opts) =>\n{\n   const events = opts.events;\n\n   if (events)\n   {\n      const handlers = events[name];\n\n      if (Array.isArray(handlers))\n      {\n         for (const handler of handlers)\n         {\n            if (handler.options.guard)\n            {\n                output.names.push(name);\n                output.guarded = true;\n                return output;\n            }\n         }\n      }\n   }\n\n   return output;\n}\n\n/**\n * The reducing API that removes a callback from the `events` object.\n *\n * @param {Events}   events - Events object\n *\n * @param {string}   name - Event name\n *\n * @param {Function} callback - Event callback\n *\n * @param {object}   opts - Optional parameters\n *\n * @returns {void|Events} Events object\n */\nconst s_OFF_API = (events, name, callback, opts) =>\n{\n   /* c8 ignore next 1 */\n   if (!events) { return; }\n\n   const context = opts.context, listeners = opts.listeners;\n   let i = 0, names;\n\n   // Delete all event listeners and \"drop\" events.\n   if (!name && !context && !callback)\n   {\n      for (names = Utils.objectKeys(listeners); i < names.length; i++)\n      {\n         listeners[names[i]].cleanup();\n      }\n      return;\n   }\n\n   names = name ? [name] : Utils.objectKeys(events);\n\n   for (; i < names.length; i++)\n   {\n      name = names[i];\n      const handlers = events[name];\n\n      // Bail out if there are no events stored.\n      if (!handlers) { break; }\n\n      // Find any remaining events.\n      const remaining = [];\n      for (let j = 0; j < handlers.length; j++)\n      {\n         const handler = handlers[j];\n         if (callback && callback !== handler.callback && callback !== handler.callback._callback ||\n          context && context !== handler.context)\n         {\n            remaining.push(handler);\n         }\n         else\n         {\n            const listening = handler.listening;\n            if (listening) { listening.off(name, callback); }\n         }\n      }\n\n      // Replace events if there are any remaining.  Otherwise, clean up.\n      if (remaining.length)\n      {\n         events[name] = remaining;\n      }\n      else\n      {\n         delete events[name];\n      }\n   }\n\n   return events;\n};\n\n/**\n * The reducing API that adds a callback to the `events` object.\n *\n * @param {Events}   events - Events object\n *\n * @param {string}   name - Event name\n *\n * @param {Function} callback - Event callback\n *\n * @param {object}   opts - Optional parameters\n *\n * @returns {Events} Events object.\n */\nconst s_ON_API = (events, name, callback, opts) =>\n{\n   if (callback)\n   {\n      const handlers = events[name] || (events[name] = []);\n      const context = opts.context, ctx = opts.ctx, listening = opts.listening;\n\n      // Make a copy of options.\n      const options = JSON.parse(JSON.stringify(opts.options));\n\n      // Ensure that guard is set.\n      options.guard = typeof options.guard === 'boolean' ? options.guard : false;\n\n      // Make sure options.type is set.\n      switch(options.type)\n      {\n         case 'sync':\n            options.type = 1;\n            break;\n         case 'async':\n            options.type = 2;\n            break;\n         default:\n            options.type = 0;\n            break;\n      }\n\n      if (listening) { listening.incrementCount(); }\n\n      handlers.push({ callback, context, ctx: context || ctx, options, listening });\n   }\n   return events;\n};\n\n/**\n * Iterates over the standard `event, callback` (as well as the fancy multiple space-separated events `\"change blur\",\n * callback` and jQuery-style event maps `{event: callback}`).\n *\n * @param {Function} iteratee - Trigger API\n *\n * @param {Function} iterateeTarget - Internal function which is dispatched to.\n *\n * @param {Events|{}}   events - Array of stored event callback data.\n *\n * @param {string}   name - Event name\n *\n * @param {Function} callback - callback\n *\n * @param {object}   opts - Optional parameters\n *\n * @returns {*} The results of the callback if any.\n */\nconst s_RESULTS_TARGET_API = (iteratee, iterateeTarget, events, name, callback, opts) =>\n{\n   let results = void 0;\n   let i = 0, names;\n\n   // Handle the case of multiple events being triggered. The potential results of each event & callbacks must be\n   // processed into a single array of results.\n   if (name && Utils.eventSplitter.test(name))\n   {\n      // Handle space-separated event names by delegating them individually.\n      for (names = name.split(Utils.eventSplitter); i < names.length; i++)\n      {\n         const result = iteratee(iterateeTarget, events, names[i], callback, opts);\n\n         // Determine type of `results`; 0: undefined, 1: single value, 2: an array of values.\n         const resultsType = Array.isArray(results) ? 2 : results !== void 0 ? 1 : 0;\n\n         // Handle an array result depending on existing results value.\n         if (Array.isArray(result))\n         {\n            switch (resultsType)\n            {\n               case 0:\n                  // Simply set results.\n                  results = result;\n                  break;\n               case 1:\n                  // Create a new array from existing results then concat the new result array.\n                  results = [results].concat(result);\n                  break;\n               case 2:\n                  // `results` is already an array so concat the new result array.\n                  results = results.concat(result);\n                  break;\n            }\n         }\n         else if (result !== void 0)\n         {\n            switch (resultsType)\n            {\n               case 0:\n                  // Simply set results.\n                  results = result;\n                  break;\n               case 1: {\n                  // Create a new array from existing results then push the new result value.\n                  const newArray = [results];\n                  newArray.push(result);\n                  results = newArray;\n                  break;\n               }\n               case 2:\n                  // `results` is already an array so push the new result array.\n                  results.push(result);\n                  break;\n            }\n         }\n      }\n   }\n   else\n   {\n      // Just single event.\n      results = iteratee(iterateeTarget, events, name, callback, opts);\n   }\n\n   return results;\n};\n\n/**\n * Handles triggering the appropriate event callbacks.\n *\n * @param {Function} iterateeTarget - Internal function which is dispatched to.\n *\n * @param {Events}   objEvents - Array of stored event callback data.\n *\n * @param {string}   name - Event name\n *\n * @param {Function} callback - callback\n *\n * @param {*[]}      args - Arguments supplied to a trigger method.\n *\n * @returns {*} The results from the triggered event.\n */\nconst s_TRIGGER_API = (iterateeTarget, objEvents, name, callback, args) =>\n{\n   let result;\n\n   if (objEvents)\n   {\n      const events = objEvents[name];\n      let allEvents = objEvents.all;\n      if (events && allEvents) { allEvents = allEvents.slice(); }\n      if (events) { result = iterateeTarget(events, args); }\n      if (allEvents) { result = iterateeTarget(allEvents, [name].concat(args)); }\n   }\n\n   return result;\n};\n\n/**\n * A difficult-to-believe, but optimized internal dispatch function for triggering events. Tries to keep the usual\n * cases speedy (most internal Backbone events have 3 arguments).\n *\n * @param {EventData[]} events - Array of stored event callback data.\n *\n * @param {*[]}         args - Event argument array\n */\nconst s_TRIGGER_EVENTS = (events, args) =>\n{\n   let ev, i = -1;\n   const a1 = args[0], a2 = args[1], a3 = args[2], l = events.length;\n\n   switch (args.length)\n   {\n      case 0:\n         while (++i < l) { (ev = events[i]).callback.call(ev.ctx); }\n         return;\n      case 1:\n         while (++i < l) { (ev = events[i]).callback.call(ev.ctx, a1); }\n         return;\n      case 2:\n         while (++i < l) { (ev = events[i]).callback.call(ev.ctx, a1, a2); }\n         return;\n      case 3:\n         while (++i < l) { (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); }\n         return;\n      default:\n         while (++i < l) { (ev = events[i]).callback.apply(ev.ctx, args); }\n         return;\n   }\n};\n\n/**\n * A difficult-to-believe, but optimized internal dispatch function for triggering events. Tries to keep the usual\n * cases speedy (most internal Backbone events have 3 arguments). This dispatch method uses ES6 Promises and adds\n * any returned results to an array which is added to a Promise.all construction which passes back a Promise which\n * waits until all Promises complete. Any target invoked may return a Promise or any result. This is very useful to\n * use for any asynchronous operations.\n *\n * @param {EventData[]} events - Array of stored event callback data.\n *\n * @param {*[]}         args - Arguments supplied to `triggerAsync`.\n *\n * @returns {Promise<void|*|*[]>} A Promise of the results from the triggered event.\n */\nconst s_TRIGGER_ASYNC_EVENTS = async (events, args) =>\n{\n   let ev, i = -1;\n   const a1 = args[0], a2 = args[1], a3 = args[2], l = events.length;\n\n   const results = [];\n\n   switch (args.length)\n   {\n      case 0:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx);\n\n            // If we received a valid result add it to the promises array.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n\n      case 1:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx, a1);\n\n            // If we received a valid result add it to the promises array.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n\n      case 2:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx, a1, a2);\n\n            // If we received a valid result add it to the promises array.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n\n      case 3:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);\n\n            // If we received a valid result add it to the promises array.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n\n      default:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.apply(ev.ctx, args);\n\n            // If we received a valid result add it to the promises array.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n   }\n\n   // If there are multiple results then use Promise.all otherwise Promise.resolve. Filter out any undefined results.\n   return results.length > 1 ? Promise.all(results).then((values) =>\n   {\n      const filtered = values.filter((entry) => entry !== void 0);\n      switch (filtered.length)\n      {\n         case 0: return void 0;\n         case 1: return filtered[0];\n         default: return filtered;\n      }\n   }) : results.length === 1 ? results[0] : void 0;\n};\n\n/**\n * A difficult-to-believe, but optimized internal dispatch function for triggering events. Tries to keep the usual\n * cases speedy (most internal Backbone events have 3 arguments). This dispatch method synchronously passes back a\n * single value or an array with all results returned by any invoked targets.\n *\n * @param {EventData[]} events - Array of stored event callback data.\n *\n * @param {*[]}         args - Arguments supplied to `triggerSync`.\n *\n * @returns {void|*|*[]} The results from the triggered event.\n */\nconst s_TRIGGER_SYNC_EVENTS = (events, args) =>\n{\n   let ev, i = -1;\n   const a1 = args[0], a2 = args[1], a3 = args[2], l = events.length;\n\n   const results = [];\n\n   switch (args.length)\n   {\n      case 0:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx);\n\n            // If we received a valid result return immediately.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n      case 1:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx, a1);\n\n            // If we received a valid result return immediately.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n      case 2:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx, a1, a2);\n\n            // If we received a valid result return immediately.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n      case 3:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);\n\n            // If we received a valid result return immediately.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n      default:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.apply(ev.ctx, args);\n\n            // If we received a valid result return immediately.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n   }\n\n   // Return the results array if there are more than one or just a single result.\n   return results.length > 1 ? results : results.length === 1 ? results[0] : void 0;\n};\n\n/**\n * A try-catch guarded function. Used when attempting to invoke `isGuarded` from an other eventbus / context via\n * `listenTo`.\n *\n * @param {object}         obj - Event target / context\n *\n * @param {string|object}  name - Event name(s) or event map.\n *\n * @param {object}         data - Output data.\n *\n * @returns {boolean} Any error if thrown.\n */\nconst s_TRY_CATCH_IS_GUARDED = (obj, name, data = {}) =>\n{\n   let guarded = false;\n\n   try\n   {\n      const result = obj.isGuarded(name, data);\n      if (typeof result === 'boolean') { guarded = result; }\n   }\n   catch (err)\n   {\n      guarded = false;\n      data.names = [];\n      data.guarded = false;\n   }\n\n   return guarded;\n};\n\n/**\n * A try-catch guarded #on function, to prevent poisoning the global `_listening` variable. Used when attempting to\n * invoke `on` from an other eventbus / context via `listenTo`.\n *\n * @param {object}            obj - Event target / context\n *\n * @param {string|object}     name - Event name(s) or event map.\n *\n * @param {Function|object}   callback - Event callback function or context for event map.\n *\n * @param {object}            [context] - Event context\n *\n * @returns {Error} Any error if thrown.\n */\nconst s_TRY_CATCH_ON = (obj, name, callback, context) =>\n{\n   try\n   {\n      obj.on(name, callback, context);\n   }\n   catch (err)\n   {\n      return err;\n   }\n};\n\n/**\n * Generate a unique integer ID (unique within the entire client session).\n *\n * @type {number} - unique ID counter.\n */\nlet idCounter = 0;\n\n/**\n * Creates a new unique ID with a given prefix\n *\n * @param {string}   prefix - An optional prefix to add to unique ID.\n *\n * @returns {string} A new unique ID with a given prefix.\n */\nconst s_UNIQUE_ID = (prefix = '') =>\n{\n   const id = `${++idCounter}`;\n   return prefix ? `${prefix}${id}` /* c8 ignore next */ : id;\n};\n","import Eventbus                        from './Eventbus.js';\n\nexport { default as EventbusProxy }    from './EventbusProxy.js';\nexport { default as EventbusSecure }   from './EventbusSecure.js';\n\nexport default Eventbus;\n\n/**\n * Provides a main eventbus instance.\n *\n * @type {Eventbus}\n */\nexport const eventbus = new Eventbus('mainEventbus');\n\n/**\n * Provides an eventbus instance potentially for use with a plugin system.\n *\n * @type {Eventbus}\n */\nexport const pluginEventbus = new Eventbus('pluginEventbus');\n\n/**\n * Provides an eventbus instance potentially for use for testing.\n *\n * @type {Eventbus}\n */\nexport const testEventbus = new Eventbus('testEventbus');\n","/**\n * Provides a single consumer queue.\n */\nexport default class Queue\n{\n   /**\n    * As the name implies, `consumer` is the sole consumer of the queue. It gets called with each element of the\n    * queue and its return value serves as a ack, determining whether the element is removed or not from the queue,\n    * allowing then subsequent elements to be processed.\n    *\n    * @param {Function} consumer - The sole consumer of the queue.\n    */\n   constructor(consumer)\n   {\n      /**\n       * The consumer of the queue.\n       *\n       * @type {Function}\n       */\n      this.consumer = consumer;\n\n      /**\n       * Storage for the queue.\n       *\n       * @type {Array}\n       */\n      this.queue = [];\n   }\n\n   /**\n    * Pushes an element on the queue.\n    *\n    * @param {*}  element - An element.\n    *\n    * @returns {Queue} This queue instance.\n    */\n   push(element)\n   {\n      this.queue.push(element);\n\n      return this.process();\n   }\n\n   /**\n    * Pushes an element on the queue.\n    *\n    * @param {Iterable<*>}  elements - An array of elements.\n    *\n    * @returns {Queue} This queue instance.\n    */\n   pushAll(elements)\n   {\n      this.queue.push(...elements);\n\n      return this.process();\n   }\n\n   /**\n    * Processes the queue.\n    *\n    * @returns {Queue} This queue instance.\n    */\n   process()\n   {\n      setTimeout(() =>\n      {\n         if (this.queue.length !== 0)\n         {\n            const ack = this.consumer(this.queue[0]);\n            if (ack)\n            {\n               this.queue.shift();\n               this.process();\n            }\n         }\n      }, 0);\n\n      return this;\n   }\n\n   /**\n    * Empties the queue.\n    *\n    * @returns {Queue} This queue instance.\n    */\n   empty()\n   {\n      this.queue = [];\n\n      return this;\n   }\n}\n","const s_DEFAULT_AUTO_CONNECT = false;\nconst s_DEFAULT_AUTO_RECONNECT = false;\nconst s_DEFAULT_BINARY_TYPE = 'blob';\nconst s_DEFAULT_CONNECT_TIMEOUT = 5000;\nconst s_DEFAULT_HOST = 'localhost';\nconst s_DEFAULT_MESSAGE_TIMEOUT = 10000;\nconst s_DEFAULT_PATH = '/';\nconst s_DEFAULT_RECONNECT_INTERVAL = 2000;\nconst s_DEFAULT_SERIALIZER = JSON;\nconst s_DEFAULT_SSL = false;\nconst s_DEFAULT_TRIGGER = true;\n\n/**\n * Parses and new client options setting default values as necessary.\n *\n * @param {NewClientOptions}  opts - Defines the options for a WebSocket client.\n *\n * @returns {ClientOptions} The parsed client options object.\n */\nexport default function setClientOptions(opts)\n{\n   if (opts === null || opts === void 0)\n   {\n      throw new TypeError(`'clientOptions' is null or undefined.`);\n   }\n\n   if (typeof opts !== 'object')\n   {\n      throw new TypeError(`'clientOptions' is not an object.`);\n   }\n\n   if (opts.url !== void 0 && typeof opts.url !== 'string' && !(opts.url instanceof URL))\n   {\n      throw new TypeError(`'clientOptions.url' is not a string or URL.`);\n   }\n\n   let url = typeof opts.url === 'string' ? new URL(opts.url.toLowerCase()) : opts.url;\n\n   if (url !== void 0 && !url.protocol.match(/^wss?/))\n   {\n      throw new TypeError(`'clientOptions.url' is not a WebSocket URL.`);\n   }\n\n   if ((url === void 0 && !Number.isInteger(opts.port)) || (opts.port < 0 || opts.port > 65535))\n   {\n      throw new TypeError(`'clientOptions.port' is not an integer between [0-65535].`);\n   }\n\n   if (opts.host !== void 0 && typeof opts.host !== 'string')\n   {\n      throw new TypeError(`'clientOptions.host' is not a string.`);\n   }\n\n   opts.host = opts.host || s_DEFAULT_HOST;\n\n   if (opts.ssl !== void 0 && typeof opts.ssl !== 'boolean')\n   {\n      throw new TypeError(`'clientOptions.ssl' is not a boolean.`);\n   }\n\n   opts.ssl = typeof opts.ssl === 'boolean' ? opts.ssl : s_DEFAULT_SSL;\n\n   if (opts.path !== void 0 && typeof opts.path !== 'string')\n   {\n      throw new TypeError(`'clientOptions.path' is not a string.`);\n   }\n\n   opts.path = typeof opts.path === 'string' ? opts.path : s_DEFAULT_PATH;\n\n   // Add a leading slash if necessary to normalize path.\n   if (!opts.path.startsWith('/')) { opts.path = `/${opts.path}`; }\n\n   if (opts.binaryType !== void 0 && typeof opts.binaryType !== 'string')\n   {\n      throw new TypeError(`'clientOptions.binaryType' must be 'blob' or 'arraybuffer'.`);\n   }\n\n   if (opts.binaryType !== void 0 && opts.binaryType !== 'blob' && opts.binaryType !== 'arraybuffer')\n   {\n      throw new TypeError(`'clientOptions.binaryType' must be 'blob' or 'arraybuffer'.`);\n   }\n\n   opts.binaryType = typeof opts.binaryType === 'string' ? opts.binaryType : s_DEFAULT_BINARY_TYPE;\n\n\n   opts.serializer = opts.serializer || s_DEFAULT_SERIALIZER;\n\n   if (typeof opts.serializer !== 'object' || typeof opts.serializer.stringify !== 'function' ||\n    typeof opts.serializer.parse !== 'function')\n   {\n      throw new TypeError(`'clientOptions.serializer' does not conform to the JSON API.`);\n   }\n\n   if (opts.autoConnect !== void 0 && typeof opts.autoConnect !== 'boolean')\n   {\n      throw new TypeError(`'clientOptions.autoConnect' is not a boolean.`);\n   }\n\n   if (opts.autoReconnect !== void 0 && typeof opts.autoReconnect !== 'boolean')\n   {\n      throw new TypeError(`'clientOptions.autoReconnect' is not a boolean.`);\n   }\n\n   if (opts.connectTimeout !== void 0 && (!Number.isInteger(opts.connectTimeout) || opts.connectTimeout < 0))\n   {\n      throw new TypeError(`'clientOptions.connectTimeout' is not an integer or < 0.`);\n   }\n\n   if (opts.messageTimeout !== void 0 && (!Number.isInteger(opts.messageTimeout) || opts.messageTimeout < 0))\n   {\n      throw new TypeError(`'clientOptions.messageTimeout' is not an integer or < 0.`);\n   }\n\n   if (opts.reconnectInterval !== void 0 && (!Number.isInteger(opts.reconnectInterval) || opts.reconnectInterval < 0))\n   {\n      throw new TypeError(`'clientOptions.reconnectInterval' is not an integer or < 0.`);\n   }\n\n\n   opts.autoConnect = typeof opts.autoConnect === 'boolean' ? opts.autoConnect : s_DEFAULT_AUTO_CONNECT;\n   opts.autoReconnect = typeof opts.autoReconnect === 'boolean' ? opts.autoReconnect : s_DEFAULT_AUTO_RECONNECT;\n   opts.connectTimeout = opts.connectTimeout || s_DEFAULT_CONNECT_TIMEOUT;\n   opts.messageTimeout = opts.messageTimeout || s_DEFAULT_MESSAGE_TIMEOUT;\n   opts.reconnectInterval = opts.reconnectInterval || s_DEFAULT_RECONNECT_INTERVAL;\n\n   if (opts.trigger !== void 0 && typeof opts.trigger !== 'boolean')\n   {\n      throw new TypeError(`'clientOptions.trigger' is not a boolean.`);\n   }\n\n   opts.trigger = typeof opts.trigger === 'boolean' ? opts.trigger : s_DEFAULT_TRIGGER;\n\n   if (opts.protocol !== void 0 && typeof opts.protocol !== 'string' && !Array.isArray(opts.protocol))\n   {\n      throw new TypeError(`'clientOptions.protocol' is not a string or string[].`);\n   }\n\n   opts.protocol = opts.protocol ? opts.protocol : [];\n\n   // Set URL from parts\n   if (url === void 0)\n   {\n      url = new URL(`${opts.ssl ? 'wss://' : 'ws://'}${opts.host}:${opts.port}${opts.path}`);\n   }\n   else  // Split parts from URL\n   {\n      opts.host = url.hostname;\n      opts.port = Number.parseInt(url.port);\n      opts.path = url.pathname;\n      opts.ssl = url.protocol.startsWith('wss');\n   }\n\n   return {\n      url: url.toString(),\n      host: opts.host,\n      port: opts.port,\n      ssl: opts.ssl,\n      path: opts.path,\n      binaryType: opts.binaryType,\n      serializer: opts.serializer,\n      autoConnect: opts.autoConnect,\n      autoReconnect: opts.autoReconnect,\n      connectTimeout: opts.connectTimeout,\n      messageTimeout: opts.messageTimeout,\n      reconnectInterval: opts.reconnectInterval,\n      protocol: opts.protocol,\n      trigger: opts.trigger\n   };\n}\n","import Eventbus         from '@typhonjs-plugin/eventbus';\n\nimport Queue            from './utils/Queue.js';\nimport setClientOptions from './utils/setClientOptions.js';\n\nconst s_STR_EVENT_CLOSE = 'socket:close';\nconst s_STR_EVENT_ERROR = 'socket:error';\nconst s_STR_EVENT_MESSAGE_IN = 'socket:message:in';\nconst s_STR_EVENT_SOCKET_OPEN = 'socket:open';\n\n/**\n * Provides a socket connection and forwarding of data via Eventbus events.\n */\nexport default class AbstractWSClient extends Eventbus\n{\n   /**\n    * The parsed client options.\n    *\n    * @type {ClientOptions}\n    */\n   #clientOptions;\n\n   /**\n    * Stores the connection status. The default message queue consumer implementation checks for 'connected' status.\n    *\n    * @type {boolean}\n    */\n   #connected = false;\n\n   /**\n    * Provides a default single consumer message queue.\n    *\n    * @type {Queue}\n    */\n   #queue;\n\n   /**\n    * @type {WebSocket}\n    */\n   #socket;\n\n   /**\n    * Provides a unique ID for messages that is incremented in `get uniqueID`.\n    * @type {number}\n    */\n   #uniqueID = 0;\n\n   /**\n    * @type {Function|WebSocket}\n    *\n    * @private\n    */\n   #WebSocketCtor;\n\n   /**\n    * Some WebSocket implementations may take an implementation specific options object as a third parameter.\n    *\n    * @type {WSClientOptions}\n    */\n   #wsOptions;\n\n   /**\n    * Creates the socket.\n    *\n    * @param {Function|WebSocket}   WebSocketCtor - The constructor for the WebSocket implementation.\n    *\n    * @param {NewClientOptions}     [clientOptions] - Defines the options for a WebSocket client.\n    *\n    * @param {WSClientOptions}      [wsOptions] - On Node `ws` is the WebSocket implementation. This object is\n    *                                             passed to the `ws` WebSocket.\n    */\n   constructor(WebSocketCtor, clientOptions = void 0, wsOptions = void 0)\n   {\n      super();\n\n      this.#WebSocketCtor = WebSocketCtor;\n\n      if (clientOptions !== void 0)\n      {\n         this.#clientOptions = setClientOptions(clientOptions);\n         this.onSetClientOptions(this.#clientOptions);\n      }\n\n      if (wsOptions !== void 0 && typeof wsOptions !== 'object')\n      {\n         throw new TypeError(`'wsOptions' is not an object.`);\n      }\n\n      if (wsOptions !== void 0)\n      {\n         this.#wsOptions = wsOptions;\n         this.onSetWSOptions(this.#wsOptions);\n      }\n\n      this.#queue = new Queue((message) =>\n      {\n         if (this.#connected) { this.send(message); return true; }\n         else { return false; }\n      });\n\n      // Potentially schedule auto connection\n      if (this.#clientOptions && this.#clientOptions.autoConnect)\n      {\n         setTimeout(this.connect.bind(this), 0);\n      }\n\n      // Provide a callback to initialize any event listeners in child classes.\n      this.onInitialize();\n   }\n\n   /**\n    * Connects the socket with potentially new client options.\n    *\n    * The `open`, `error` and `close` events are simply proxy-ed to `_socket`. The `message` event is instead parsed\n    * into a js object (if possible) and then passed as a parameter of the `message:in` event.\n    *\n    * @param {object}            options - Optional parameters.\n    *\n    * @param {NewClientOptions}  [options.clientOptions] - Defines the options for a WebSocket client.\n    *\n    * @param {WSClientOptions}   [options.wsOptions] - On Node `ws` is the WebSocket implementation. This object is\n    *                                                  passed to the `ws` WebSocket.\n    *\n    * @param {number}            [options.timeout] - Indicates a timeout in ms for connection attempt.\n    *\n    * @returns {Promise<void|object>} A Promise resolved when connected or rejected with an error / timeout.\n    */\n   async connect({ clientOptions = void 0, wsOptions = void 0, timeout = void 0 } = {})\n   {\n      if (this.#socket)\n      {\n         return Promise.reject({\n            message: 'WSClient [connect] already created WebSocket.',\n            type: 'error'\n         });\n      }\n\n      if (clientOptions !== void 0)\n      {\n         this.#clientOptions = setClientOptions(clientOptions);\n         this.onSetClientOptions(this.#clientOptions);\n      }\n\n      if (wsOptions !== void 0 && typeof wsOptions !== 'object')\n      {\n         throw new TypeError(`'wsOptions' is not an object.`);\n      }\n\n      if (wsOptions !== void 0)\n      {\n         this.#wsOptions = wsOptions;\n         this.onSetWSOptions(this.#wsOptions);\n      }\n\n      if (typeof this.#clientOptions !== 'object')\n      {\n         return Promise.reject({\n            message: `WSClient [connect] 'clientOptions' has not been set.`,\n            type: 'error'\n         });\n      }\n\n      // Assign default timeout if not specified.\n      if (timeout === void 0)\n      {\n         timeout = this.clientOptions.connectTimeout;\n      }\n\n      if (!Number.isInteger(timeout) || timeout < 0)\n      {\n         throw new TypeError(`'timeout' must be a positive integer.`);\n      }\n\n      if (this.#wsOptions !== void 0)\n      {\n         this.#socket = new this.#WebSocketCtor(this.url, this.#clientOptions.protocol, this.#wsOptions);\n      }\n      else\n      {\n         this.#socket = new this.#WebSocketCtor(this.url, this.#clientOptions.protocol);\n      }\n\n      this.#socket.binaryType = this.#clientOptions.binaryType;\n\n      this.#socket.onclose = () =>\n      {\n         this.#connected = false;\n         this.#socket = void 0;\n\n         this.onSocketClose();\n\n         if (this.#clientOptions.trigger) { super.triggerDefer(s_STR_EVENT_CLOSE); }\n\n         if (this.#clientOptions.autoReconnect)\n         {\n            // Schedule a reconnection\n            setTimeout(this.connect.bind(this), this.#clientOptions.reconnectInterval);\n         }\n      };\n\n      this.#socket.onerror = (error) =>\n      {\n         this.onSocketError(error);\n\n         if (this.#clientOptions.trigger) { super.triggerDefer(s_STR_EVENT_ERROR, error); }\n      };\n\n      this.#socket.onmessage = (event) =>\n      {\n         let data;\n\n         try\n         {\n            data = typeof event.data === 'string' ? this.#clientOptions.serializer.parse(event.data) : event.data;\n         }\n         catch (err)\n         {\n            data = event.data;\n         }\n\n         this.onSocketMessage(data);\n\n         if (this.#clientOptions.trigger) { super.triggerDefer(s_STR_EVENT_MESSAGE_IN, data); }\n      };\n\n      this.#socket.onopen = () =>\n      {\n         this.#connected = true;\n\n         this.onSocketOpen();\n\n         if (this.#clientOptions.trigger) { super.triggerDefer(s_STR_EVENT_SOCKET_OPEN); }\n\n         this.#queue.process();\n      };\n\n      return new Promise((resolve, reject) =>\n      {\n         const onTimeout = setTimeout(() =>\n         {\n            reject({ message: 'WSClient [connect] timed out.', type: 'error' });\n         }, timeout);\n\n         const onError = (error) =>\n         {\n            reject(error);\n         }\n\n         const onOpen = () =>\n         {\n            clearTimeout(onTimeout);\n\n            if (this.#socket)\n            {\n               this.#socket.removeEventListener('error', onOpen);\n               this.#socket.removeEventListener('error', onError);\n            }\n\n            resolve();\n         }\n\n         this.#socket.addEventListener('open', onOpen);\n         this.#socket.addEventListener('error', onError);\n      });\n   }\n\n   /**\n    * Disconnects / closes the socket.\n    *\n    * @param {object}   options - Optional parameters.\n    *\n    * @param {number}   [options.code] - A numeric value indicating the status code explaining why the connection is\n    *                                    being closed. If this parameter is not specified, a default value of 1005\n    *                                    is assumed. See the list of status codes of CloseEvent for permitted values.\n    *\n    * @param {string}   [options.reason] - A human-readable string explaining why the connection is closing. This string\n    *                                      must be no longer than 123 bytes of UTF-8 text (not characters).\n    *\n    * @see https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#status_codes\n    *\n    * @returns {Promise<void|object>} A Promise that resolves when socket is closed or rejected with an error.\n    */\n   async disconnect({ code, reason } = {})\n   {\n      let promise;\n\n      if (this.#socket)\n      {\n         promise = new Promise((resolve, reject) =>\n         {\n            this.#socket.addEventListener('close', () =>\n            {\n               resolve();\n            });\n            this.#socket.addEventListener('error', (error) =>\n            {\n               reject(error);\n            });\n         })\n\n         this.#socket.close(code, reason);\n      }\n\n      this.#connected = false;\n\n      this.#queue.empty();\n\n      return promise;\n   }\n\n   /**\n    * Read-only property returns the number of bytes of data that have been queued using calls to send() but not yet\n    * transmitted to the network. This value resets to zero once all queued data has been sent. This value does not\n    * reset to zero when the connection is closed; if you keep calling send(), this will continue to climb.\n    *\n    * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/bufferedAmount\n    * @returns {number} Current buffered amount.\n    */\n   get bufferedAmount() { return this.#socket ? this.#socket.bufferedAmount : 0; }\n\n   /**\n    * @returns {ClientOptions} Current client options\n    */\n   get clientOptions() { return this.#clientOptions; }\n\n   /**\n    * @returns {boolean} Current connected status.\n    */\n   get connected() { return this.#connected; }\n\n   /**\n    * Read-only property returns the extensions selected by the server. This is currently only the empty string or a\n    * list of extensions as negotiated by the connection.\n    *\n    * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/extensions\n    * @returns {string} Server extensions.\n    */\n   get extensions() { return this.#socket ? this.#socket.extensions : ''; }\n\n   /**\n    * Read-only property returns the name of the sub-protocol the server selected; this will be one of the strings\n    * specified in the protocols parameter when creating the WebSocket object, or the empty string if no connection is\n    * established.\n    *\n    * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/protocol\n    * @returns {string} Server sub-protocol.\n    */\n   get protocol() { return this.#socket ? this.#socket.protocol : ''; }\n\n   /**\n    * Returns a unique ID for messaging. The ID is incremented by 1 everytime this method is invoked.\n    *\n    * @returns {number} A unique ID for messaging.\n    */\n   get uniqueID() { return this.#uniqueID++; }\n\n   /**\n    * @returns {Queue} The message queue.\n    */\n   get queue() { return this.#queue; }\n\n   /**\n    * Read-only property returns the current state of the WebSocket connection.\n    *\n    * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/readyState\n    * @returns {number} Current state of WebSocket.\n    */\n   get readyState() { return this.#socket ? this.#socket.readyState : 3; }\n\n   /**\n    * Read-only property returns the absolute URL of the WebSocket as resolved by the constructor.\n    *\n    * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/url\n    * @returns {string} Absolute URL of the WebSocket.\n    */\n   get url()\n   {\n      return this.#socket ? this.#socket.url :\n       this.#clientOptions ? this.#clientOptions.url : '';\n   }\n\n   /**\n    * Any 'ws' options set for Node WebSocket implementation.\n    *\n    * @returns {WSClientOptions}\n    */\n   get wsOptions() { return this.#wsOptions; }\n\n   /**\n    * Invoked after the initial setup in the constructor.\n    */\n   onInitialize() {}\n\n   /**\n    * Invoked when clientOptions is set. Allows child classes to manipulate clientOptions.\n    *\n    * @param {ClientOptions}  clientOptions - The newly set clientOptions.\n    */\n   onSetClientOptions(clientOptions) {}\n\n   /**\n    * Invoked when wsOptions is set. Allows child classes to manipulate wsOptions.\n    *\n    * @param {WSClientOptions}   wsOptions - The newly set wsOptions.\n    */\n   onSetWSOptions(wsOptions) {}\n\n   /**\n    * 'onclose' direct method callback.\n    */\n   onSocketClose() {}\n\n   /**\n    * 'onerror' direct method callback.\n    *\n    * @param {object}   error - The error event.\n    */\n   onSocketError(error) {}\n\n   /**\n    * 'onmessage' direct method callback.\n    *\n    * @param {*}  data - The data received.\n    */\n   onSocketMessage(data) {}\n\n   /**\n    * 'onopen' direct method callback.\n    */\n   onSocketOpen() {}\n\n   /**\n    * Reconnects the socket with potentially new client options. First disconnects if currently connected.\n    *\n    * @param {object}            options - Optional parameters.\n    *\n    * @param {NewClientOptions}  [options.clientOptions] - Defines the options for a WebSocket client.\n    *\n    * @param {WSClientOptions}   [options.wsOptions] - On Node `ws` is the WebSocket implementation. This object is\n    *                                                  passed to the `ws` WebSocket.\n    *\n    * @param {number}            [options.code=1000] - A numeric value indicating the status code explaining why the\n    *                            connection is being closed. If this parameter is not specified, a default value of 1000\n    *                            is assumed indicating normal closure. See the list of status codes of CloseEvent for\n    *                            permitted values.\n    *\n    * @param {string}            [options.reason='reconnecting'] - A human-readable string explaining why the connection\n    *                            is closing. This string must be no longer than 123 bytes of UTF-8 text (not characters).\n    *\n    * @param {number}            [options.timeout=5000] - Indicates a timeout in ms for connection attempt.\n    *\n    * @see https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#status_codes\n    * @see https://github.com/websockets/ws/blob/HEAD/doc/ws.md#new-websocketaddress-protocols-options\n    *\n    * @returns {Promise<void|object>} A Promise resolved when reconnected or rejected with an error / timeout.\n    */\n   async reconnect({ clientOptions = void 0, wsOptions = void 0, code = 1000, reason = 'reconnecting', timeout } = {})\n   {\n      if (clientOptions !== void 0)\n      {\n         this.#clientOptions = setClientOptions(clientOptions);\n         this.onSetClientOptions(this.#clientOptions);\n      }\n\n      if (wsOptions !== void 0 && typeof wsOptions !== 'object')\n      {\n         throw new TypeError(`'wsOptions' is not an object.`);\n      }\n\n      if (wsOptions !== void 0)\n      {\n         this.#wsOptions = wsOptions;\n         this.onSetWSOptions(this.#wsOptions);\n      }\n\n      await this.disconnect({ code, reason });\n\n      return this.connect({ timeout });\n   }\n\n   /**\n    * Sends an object over the socket.\n    *\n    * @param {object|string|Blob|ArrayBuffer|ArrayBufferView}  data - The data to send.\n    *\n    * @returns {AbstractWSClient} This WSClient instance.\n    */\n   send(data)\n   {\n      if (this.#socket && this.#clientOptions)\n      {\n         this.#socket.send(data.constructor === Object ? this.#clientOptions.serializer.stringify(data) : data);\n      }\n\n      return this;\n   }\n\n   /**\n    * Sends an object over the socket.\n    *\n    * @param {Iterable<object|string|Blob|ArrayBuffer|ArrayBufferView>}  data - An array of data to send.\n    *\n    * @returns {AbstractWSClient} This WSClient instance.\n    */\n   sendAll(data)\n   {\n      if (this.#socket && this.#clientOptions)\n      {\n         for (const entry of data)\n         {\n            this.#socket.send(entry.constructor === Object ? this.#clientOptions.serializer.stringify(entry) : entry);\n         }\n      }\n\n      return this;\n   }\n\n   /**\n    * Sets clientOptions / wsOptions. Most useful when loading options indirectly.\n    *\n    * @param {object}            options - Optional parameters.\n    *\n    * @param {NewClientOptions}  [options.clientOptions] - Defines the options for a WebSocket client.\n    *\n    * @param {WSClientOptions}   [options.wsOptions] - On Node `ws` is the WebSocket implementation. This object is\n    *                                                  passed to the `ws` WebSocket.\n    */\n   setOptions({ clientOptions = void 0, wsOptions = void 0 } = {})\n   {\n      if (clientOptions !== void 0)\n      {\n         this.#clientOptions = setClientOptions(clientOptions);\n         this.onSetClientOptions(this.#clientOptions);\n      }\n\n      if (wsOptions !== void 0 && typeof wsOptions !== 'object')\n      {\n         throw new TypeError(`'wsOptions' is not an object.`);\n      }\n\n      if (wsOptions !== void 0)\n      {\n         this.#wsOptions = wsOptions;\n         this.onSetWSOptions(this.#wsOptions);\n      }\n   }\n}\n","import AbstractWSClient from '../AbstractWSClient.js';\n\n/**\n * Provides the browser version of WSClient. The function overrides provide protection to not set any provided\n * 'wsOptions' as the browser WebSocket implementation doesn't take a 3rd options object parameter.\n */\nexport default class WSClient extends AbstractWSClient\n{\n   /**\n    * @param {NewClientOptions}  [clientOptions] - Defines the options for a WebSocket client.\n    *\n    * @param {WSClientOptions}   [wsOptions] - On Node `ws` is the WebSocket implementation. This object is passed\n    *                                          to the `ws` WebSocket. Ignored for the browser.\n    */\n   constructor(clientOptions = void 0, wsOptions = void 0) // eslint-disable-line no-unused-vars\n   {\n      super(WebSocket, clientOptions); // eslint-disable-line no-undef\n   }\n\n   /**\n    * Connects the socket with potentially new client options.\n    *\n    * The `open`, `error` and `close` events are simply proxy-ed to `_socket`. The `message` event is instead parsed\n    * into a js object (if possible) and then passed as a parameter of the `message:in` event.\n    *\n    * @param {object}            options - Optional parameters.\n    *\n    * @param {NewClientOptions}  [options.clientOptions] - Defines the options for a WebSocket client.\n    *\n    * @param {WSClientOptions}   [options.wsOptions] - On Node `ws` is the WebSocket implementation. This object is\n    *                                                  passed to the `ws` WebSocket.\n    *\n    * @param {number}            [options.timeout] - Indicates a timeout in ms for connection attempt.\n    *\n    * @returns {Promise<void|object>} A Promise resolved when connected or rejected with an error / timeout.\n    * @override\n    */\n   async connect({ clientOptions = void 0, wsOptions = void 0, timeout = void 0 } = {}) // eslint-disable-line no-unused-vars\n   {\n      return super.connect({ clientOptions, wsOptions: void 0, timeout });\n   }\n\n   /**\n    * Reconnects the socket with potentially new client options. First disconnects if currently connected.\n    *\n    * @param {object}            [options] - Optional parameters.\n    *\n    * @param {NewClientOptions}  [options.clientOptions] - Defines the options for a WebSocket client.\n    *\n    * @param {WSClientOptions}   [options.wsOptions] - Unused options for browser WebSocket.\n    *\n    * @param {number}            [options.code=1000] - A numeric value indicating the status code explaining why the\n    *                            connection is being closed. If this parameter is not specified, a default value of 1000\n    *                            is assumed indicating normal closure. See the list of status codes of CloseEvent for\n    *                            permitted values.\n    *\n    * @param {string}            [options.reason='reconnecting'] - A human-readable string explaining why the connection\n    *                            is closing. This string must be no longer than 123 bytes of UTF-8 text (not\n    *                            characters).\n    *\n    * @param {number}            [options.timeout=5000] - Indicates a timeout in ms for connection attempt.\n    *\n    * @see https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#status_codes\n    * @see https://github.com/websockets/ws/blob/HEAD/doc/ws.md#new-websocketaddress-protocols-options\n    *\n    * @returns {Promise<void|object>} A Promise resolved when reconnected or rejected with an error / timeout.\n    * @override\n    */\n   async reconnect({ clientOptions = void 0, wsOptions = void 0, code = 1000, reason = 'reconnecting', timeout } = {})  // eslint-disable-line no-unused-vars\n   {\n      return super.reconnect({ clientOptions, wsOptions: void 0, code, reason, timeout });\n   }\n\n   /**\n    * Sets clientOptions / wsOptions. Most useful when loading options indirectly.\n    *\n    * @param {object}            options - Optional parameters.\n    *\n    * @param {NewClientOptions}  [options.clientOptions] - Defines the options for a WebSocket client.\n    *\n    * @param {WSClientOptions}   [options.wsOptions] - On Node `ws` is the WebSocket implementation. This object is\n    *                                                  passed to the `ws` WebSocket.\n    *\n    * @override\n    */\n   setOptions({ clientOptions = void 0, wsOptions = void 0 } = {})   // eslint-disable-line no-unused-vars\n   {\n      super.setOptions({ clientOptions, wsOptions: void 0 });\n   }\n}\n","export default class WSServer\n{\n   constructor() { throw new ReferenceError(`'WSServer' is only available on Node.`); }\n}\n"],"names":["eventSplitter","eventsAPI","iteratee","events","name","callback","opts","names","i","context","objectKeys","length","test","split","getErrorName","eventbus","getOptions","output","handlers","Array","isArray","handler","options","guard","type","object","Object","keys","beforeMap","map","after","count","beforeWrapper","s_BEFORE","apply","this","arguments","_callback","before","result","args","Eventbus","constructor","TypeError","_listeners","_listenId","_listeningTo","Number","isInteger","data","isGuarded","console","warn","Utils","JSON","stringify","off","bind","on","regex","RegExp","event","_classPrivateFieldGet","parse","getType","s_GET_TYPE","guarded","s_IS_GUARDED","listenTo","obj","s_TRY_CATCH_IS_GUARDED","id","s_UNIQUE_ID","listeningTo","listening","_listening","Listening","error","s_TRY_CATCH_ON","interop","listenToBefore","stopListening","listenToOnce","s_OFF_API","listeners","s_ON_API","ctx","once","ids","trigger","s_RESULTS_TARGET_API","s_TRIGGER_API","s_TRIGGER_EVENTS","s_TRIGGER_ASYNC_EVENTS","Promise","all","then","results","allResults","pResult","concat","push","triggerDefer","setTimeout","triggerSync","s_TRIGGER_SYNC_EVENTS","listener","cleanup","incrementCount","value","remaining","j","iterateeTarget","resultsType","newArray","objEvents","allEvents","slice","ev","a1","a2","a3","l","call","async","values","filtered","filter","entry","err","idCounter","prefix","Queue","consumer","queue","element","process","pushAll","elements","shift","empty","s_DEFAULT_SERIALIZER","setClientOptions","url","URL","toLowerCase","protocol","match","port","host","ssl","path","startsWith","binaryType","serializer","autoConnect","autoReconnect","connectTimeout","messageTimeout","reconnectInterval","hostname","parseInt","pathname","toString","AbstractWSClient","WebSocketCtor","clientOptions","wsOptions","onSetClientOptions","onSetWSOptions","message","send","connect","onInitialize","timeout","reject","onclose","onSocketClose","onerror","onSocketError","onmessage","onSocketMessage","onopen","onSocketOpen","resolve","onTimeout","onError","onOpen","clearTimeout","removeEventListener","addEventListener","code","reason","promise","close","bufferedAmount","extensions","readyState","disconnect","sendAll","setOptions","WSClient","WebSocket","super","reconnect","WSServer","ReferenceError"],"mappings":"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"}